(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{790:function(v,l,_){"use strict";_.r(l);var e=_(29),i=Object(e.a)({},(function(){var v=this,l=v.$createElement,_=v._self._c||l;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"响应式布局适配方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#响应式布局适配方案"}},[v._v("#")]),v._v(" 响应式布局适配方案")]),v._v(" "),_("p",[v._v("响应式布局的几种典型方案，具体如下：")]),v._v(" "),_("ul",[_("li",[v._v("传统布局")]),v._v(" "),_("li",[v._v("相当单位布局")]),v._v(" "),_("li",[v._v("通过媒体查询实现的响应式布局")]),v._v(" "),_("li",[v._v("基于相对单位 rem 的 flexible 布局")]),v._v(" "),_("li",[v._v("flex 布局")]),v._v(" "),_("li",[v._v("grid 布局")]),v._v(" "),_("li",[v._v("借助 JavaScript 进行布局")])]),v._v(" "),_("p",[v._v("传统布局也就是多栏自适应布局，这种实现方式比较传统，且实现方式比较复杂。同时对整体布局侵入影响较大。除了传统布局，我们还会经常用到相对单位布局，这种实现方式比较容易，下面是 CSS 中相对单位：")]),v._v(" "),_("ul",[_("li",[v._v("em：相对于当前元素或当前元素继承来的字体的宽度，但是每个字母或汉字的宽度有可能是不一样的，一般来说是一个大写字母 M 的宽度（事实上，规范中有一个 x-height 概念，建议取 X 的高度，但并没有推荐绝对的计算执行标准，还需要看浏览器的实现，也有的地方采用 O 的高度）；一个非常容易出错的点在于，em 并不全是相对于父元素的字体大小，相对于谁取决于应用在什么 CSS 属性上。对于 font-size 来说，em 是相对于父元素的字体大小；在 line-height 中，em 却是相对于自身的字体大小。")]),v._v(" "),_("li",[v._v("rem：相对于根节点（html）的字体大小")])]),v._v(" "),_("p",[v._v("上面这两个单位在响应式布局中非常重要，淘宝的 flexible 布局方案就是以 rem 为核心的。")]),v._v(" "),_("ul",[_("li",[v._v("vw：相对于视口宽度，100vw 就相当于一个视口宽度。")]),v._v(" "),_("li",[v._v("vh：同 vw，1vh 表示一个视口高度的 1/100，100vh 就是一个视口高度。")]),v._v(" "),_("li",[v._v("vmin、vmax：vmin 相对于视口的宽度或高度中较小的那个，也就是在 1vw 和 1vh 之间取最小值（Math.min(1vw, 1vh)）;")]),v._v(" "),_("li",[v._v("%")]),v._v(" "),_("li",[v._v("calc()")])])])}),[],!1,null,null,null);l.default=i.exports}}]);