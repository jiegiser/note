(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{797:function(e,t,v){"use strict";v.r(t);var r=v(29),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("已下通过从数据绑定、组件化和数据流、数据状态管理、渲染和更新等方面进行对比两个框架；")]),e._v(" "),v("h2",{attrs:{id:"数据绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据绑定"}},[e._v("#")]),e._v(" 数据绑定")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("vue 在数据绑定上采取双向绑定。依靠 Object.defineProperty(vue3 已迁移到 Proxy) 及监听 DOM 事件实现。简单来说就是，为了监听数据变化，我们需要对数据进行拦截/代理；对于监听视图的改变，我们需要对 DOM 事件（如 onInput、onChange 等）进行监听。")])]),e._v(" "),v("li",[v("p",[e._v("react 中并没有数据和视图之间的双向绑定，他的策略是 “局部刷新”，当数据发生变化时，直接重新渲染组件，便可以得到最新的视图。框架对这种刷新在性能上提供了一定的保障。")])])]),e._v(" "),v("p",[e._v("这里需要区分的是双向绑定和单项数据流并没有直接关系，双向绑定是指数据和视图之间的绑定关系，而单项数据流是指组件之间的数据传递。")]),e._v(" "),v("h2",{attrs:{id:"组件化和数据流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件化和数据流"}},[e._v("#")]),e._v(" 组件化和数据流")]),e._v(" "),v("p",[e._v("vue 组件 不像 react 组件，他不是完全以组件功能和 UI 为维度进行划分的，vue 组件本质上是一个 vue 实例。每个 vue 实例在创建时都需要经过以下几个步骤：设置数据监听、编译模板。将模板应用到 DOM 上，而且要在更新时根据数据变化更新 DOM\n的过程。在这个过程，vue 也像 react 一样提供了类似组件的声明周期的方法。")]),e._v(" "),v("p",[e._v("vue 组件之间的通信，或者说组件间数据流，同 react 一样，也是单向的。他们在数据流向上也很类似，即通过 props 实现父组件向下传递数据，vue 基于 events 实现子组件向上发送消息给父组件，react 基于 props 的回调来实现子组件向父组件传递数据。vue 也支持回调的方式传递数据。")]),e._v(" "),v("h2",{attrs:{id:"数据状态管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据状态管理"}},[e._v("#")]),e._v(" 数据状态管理")]),e._v(" "),v("p",[e._v("对于较为复杂的数据状态，redux 是 react 应用开发中最常用的解决方案。vue 应用开发中常用的是 vuex，跟 redux 很类似，不允许组件直接修改 store state，而是需要\n使用 dispatch action 来通知 store 的变化。这个过程不同于 redux 的函数式思想，其中的一个区别就是，vuex 改变 store 的方法支持提交一个 mutation，而 redux 并不支持。\nmutation 类似于事件发布/订阅系统：每个 mutation 都通过一个字符串来表示事件类型，并通过一个回调函数来进行对应的数据修改。另一个显著的区别是，在 vuex 中，store\n是被直接注入到组件的实例中，因为用起来更加方便。而 redux 需要通过 connect 方法把 props 和 dispatch 注入组件中。")]),e._v(" "),v("p",[e._v("造成上面这些不同的本质原因可能有下：")]),e._v(" "),v("ul",[v("li",[e._v("redux 提倡不可变性，而 vuex 的数据是可变的，redux 中的 reducer 每次都会生成新的 state 以替代旧的 state，而 vuex 是直接进行修改。")]),e._v(" "),v("li",[e._v("redux 在检测数据变化时，是通过浅比较的方式比较差异的，而 vuex 其实和 vue 的原理一样，是通过遍历数据的 getter/setter 来比较的。")])]),e._v(" "),v("h2",{attrs:{id:"渲染和更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染和更新"}},[e._v("#")]),e._v(" 渲染和更新")]),e._v(" "),v("p",[e._v("react 和 redux 倡导不可变性，更新需要维持不可变原则，而 vue 对数据进行了拦截/代理，因此他不要求维持不可变性，而允许开发者修改数据，以引起响应式更新。")]),e._v(" "),v("p",[e._v("react 更像 MVC 或 MVVM 模式中的 view 层，但是与 redux 等搭配后，他也是一个完整的 MVVM类库。vue 直接是 MVVM 模式的典型体现；")]),e._v(" "),v("p",[e._v("react 所有组件都依靠灵活且强大的 JSX，JSX 被转换为普通 JavaScript 对象，用来表示虚拟 DOM。")]),e._v(" "),v("p",[e._v("vue template 是典型的模板，比 JSX 在表达上更加自然。在底层实现上， vue 模板被编译成 DOM 渲染函数，结合响应系统，进行数据依赖的收集。vue 渲染的过程如下：")]),e._v(" "),v("ol",[v("li",[e._v("通过 new Vue 语句实例化 vue 对象。")]),e._v(" "),v("li",[e._v("挂载 $mount 方法，通过自定义 Render 方法、template、el 等生成 Render 函数，准备渲染。")]),e._v(" "),v("li",[e._v("通过 Watcher 进行依赖收集。")]),e._v(" "),v("li",[e._v("当数据变化时，执行 Render 函数并生成 VNode 对象。")]),e._v(" "),v("li",[e._v("通过 patch 方法，对比新旧 VNode 对象，通过 DOM diff 算法添加、修改、删除真正的 DOM 元素。\nvue 也支持 JSX。")])]),e._v(" "),v("p",[e._v("关于更新的性能问题，简单来说，在 react 应用中，当某个组件的状态发生变化时，他就会以该组件为根，重新渲染整个组件子树。当然，我们可以使用 PureComponent ，\n或是手动实现 shouldComponentUpdate 方法，来避免不需要的渲染。")]),e._v(" "),v("p",[e._v("在 vue 应用中，组件的依赖是在渲染过程中自动追踪的，因此系统能精确地知晓哪个组件需要被重新渲染。从理论上看，vue 的渲染更新机制更加细粒度，也更加精确。")])])}),[],!1,null,null,null);t.default=a.exports}}]);