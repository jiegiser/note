(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{365:function(t,a){t.exports="data:image/png;base64,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"},582:function(t,a,s){"use strict";s.r(a);var n=s(25),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"变量、作用域和内存问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#变量、作用域和内存问题"}},[t._v("#")]),t._v(" 变量、作用域和内存问题")]),t._v(" "),n("h3",{attrs:{id:"检测类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#检测类型"}},[t._v("#")]),t._v(" 检测类型")]),t._v(" "),n("p",[t._v("typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具；这里主要注意的是 typeof 可以检查是不是函数类型。如果是函数，返回 'function'；如果变量是一个对象或者 null，则 typeof 操作符会返回 'object'：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("a")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" a "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" n "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// object")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" o "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" o "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// object")]),t._v("\n")])])]),n("p",[t._v("检测变量是给定引用类型的实例，可以使用 instanceof 操作符，其语法如下：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v("result "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" variable "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("constructor")]),t._v("\n")])])]),n("p",[t._v("例子:")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v("person "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 变量 person 是 Object 实例吗？")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("a")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\na "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),n("p",[t._v("这里需要注意的是，所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造函数时，instanceof 操作符始终会返回 true。当然，如果使用 instanceof 操作符检测基本类型的值，就会返回 false，因为基本类型不是对象。")]),t._v(" "),n("h3",{attrs:{id:"执行环境以及作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#执行环境以及作用域"}},[t._v("#")]),t._v(" 执行环境以及作用域")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。")])]),t._v(" "),n("li",[n("p",[t._v("每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。（虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。）")])]),t._v(" "),n("li",[n("p",[t._v("根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。")])]),t._v(" "),n("li",[n("p",[t._v("全局执行环境是最外围的一个执行环境。在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都在window对象上，所有全局变量和函数都是作为 window 对象的属性和方法创建的。")])]),t._v(" "),n("li",[n("p",[t._v("某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）")])]),t._v(" "),n("li",[n("p",[t._v("每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。")])]),t._v(" "),n("li",[n("p",[t._v("当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）；作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在的执行环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。")])]),t._v(" "),n("li",[n("p",[t._v("标识符解析（变量解析过程）是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。")])])]),t._v(" "),n("p",[t._v("例子：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeColor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'red'")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeColor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Color is now '")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" color"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),n("p",[t._v("上面例子中，函数 changeColor() 的作用域链包含两个对象：它自己的变量对象（其中定义着 arguments 对象）和全局环境的变量对象。可以在函数内部访问变量 color ，就是因为可以在这个作用域链中找到它。")]),t._v(" "),n("p",[t._v("在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下例子：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeColor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" anotherColor "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'red'")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapColors")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" tempColor "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" anotherColor\n      anotherColor "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" color\n      color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tempColor\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里可以访问 color、anotherColor 和 tempColor")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里可以访问 color 和 anotherColor，但不能访问 tempColor")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapColors")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里只能访问 color")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeColor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),n("p",[t._v("以上代码共涉及 3 个执行环境：全局环境、changeColor() 的局部环境和 swapColors() 的局部环境。全局环境中有一个变量color 和一个函数 changeColor()。changeColor() 的局部环境中有一个名为 anotherColor 的变量和一个名为 swapColors() 的函数，但它也可以访问全局环境中的变量 color。swapColors() 的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。无论全局环境还是 changeColor() 的局部环境都无权访问 tempColor。然而，在 swapColors() 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(365),alt:"在这里插入图片描述"}})]),t._v(" "),n("p",[t._v("内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。")]),t._v(" "),n("p",[t._v("对于这个例子中的 swapColors() 而言，其作用域链中包含 3 个对象： swapColors() 的变量对象、 changeColor() 的变量对象和全局变量对象。swapColors() 的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。 changeColor() 的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问 swapColors() 的环境。")]),t._v(" "),n("h4",{attrs:{id:"延长作用域链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#延长作用域链"}},[t._v("#")]),t._v(" 延长作用域链")]),t._v(" "),n("p",[t._v("虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。具体来说就是当执行流进入下列任何一个语句时，作用域链就会得到加长：")]),t._v(" "),n("ul",[n("li",[t._v("try-catch 语句的 catch 块")]),t._v(" "),n("li",[t._v("with 语句")])]),t._v(" "),n("p",[t._v("这两个语句都会在作用域链的前端添加一个变量对象；但是不同的是：")]),t._v(" "),n("ul",[n("li",[t._v("对 with 语句来说，会将指定的对象添加到作用域链中。")]),t._v(" "),n("li",[t._v("对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。")])]),t._v(" "),n("p",[t._v("如下代码：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("buildUrl")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" qs "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'?debug=true'")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("with")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("location"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" url "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" href "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" qs\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" url\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("上面代码中， with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl() 函数中定义了一个变量 qs 。当在 with 语句中引用变量 href 时（实际引用的是 location.href），可以在当前执行环境的变量对象中找到。当引用变量 qs 时，引用的则是在 buildUrl() 中定义的那个变量，而该变量位于函数环境的变量对象中。至于 with 语句内部，则定义了一个名为 url 的变量，因而 url 就成了函数执行环境的一部分，所以可以作为函数的值被返回。")]),t._v(" "),n("h4",{attrs:{id:"块级作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[t._v("#")]),t._v(" 块级作用域")]),t._v(" "),n("p",[t._v("使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。")]),t._v(" "),n("p",[t._v("使用 let、const 定义的变量，存在块级作用域。")]),t._v(" "),n("h4",{attrs:{id:"变量的查找"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#变量的查找"}},[t._v("#")]),t._v(" 变量的查找")]),t._v(" "),n("p",[t._v("在查找一个变量时是从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。")]),t._v(" "),n("p",[t._v("如下例子：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getColor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" color\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getColor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 'blue'")]),t._v("\n")])])]),n("p",[t._v("调用本例中的函数 getColor() 时会引用变量 color。为了确定变量 color 的值，将开始一个两步的搜索过程。首先，搜索 getColor() 的变量对象，查找其中是否包含一个名为 color 的标识符。在没有找到的情况下，搜索继续到下一个变量对象（全局环境的变量对象），然后在那里找到了名为 color 的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。\n在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。如下代码：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getColor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" color "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'red'")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" color\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getColor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// red")]),t._v("\n\n")])])]),n("p",[t._v('修改后的代码在 getColor() 函数中声明了一个名为 color 的局部变量。调用函数时，该变量就会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量 color 的值。搜索过程首先从局部环境中开始，而且在这里发现了一个名为 color 的变量，其值为 "red"。因为变量已经找到了，所以搜索即行停止，return 语句就使用这个局部变量，并为函数会返回 "red" 。也就是说，任何位于局部变量 color 的声明之后的代码，如果不使用 window.color 都无法访问全局 color变量。')]),t._v(" "),n("blockquote",[n("p",[t._v("变量查询也不是没有代价的。很明显，访问局部变量比访问全局变量更快，因为不用向上搜素作用域链。JavaScript 引擎在优化标识符查询方面做的不错，因此这个差别在将来恐怕就可以忽略不计了。")])]),t._v(" "),n("h3",{attrs:{id:"垃圾收集"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集"}},[t._v("#")]),t._v(" 垃圾收集")]),t._v(" "),n("p",[t._v("JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++ 之类的语言中，开发人员你的意向基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在 JavaScript 中所需内存的分配以及无用内存的回收完全实现了自动管理。")]),t._v(" "),n("p",[t._v("垃圾回收机制的原理其实很简单：找出那些不在继续使用的变量，然后释放其占用的内存。为此，垃圾收集齐会按照固定的时间间隔（或者代码执行中预定的收集时间），周期性地执行这一操作。")]),t._v(" "),n("p",[t._v("我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以存储他们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放他们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集齐必须跟踪哪个变量有用哪个变量没用，对于不在有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两种策略：标记清除、引用计数")]),t._v(" "),n("h4",{attrs:{id:"javascript-中的栈内存与堆内存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中的栈内存与堆内存"}},[t._v("#")]),t._v(" JavaScript 中的栈内存与堆内存")]),t._v(" "),n("p",[t._v("上述过程中，JavaScript 中变量分为基本类型值和引用类型值：")]),t._v(" "),n("ul",[n("li",[t._v("基本类型值在内存中占固定大小的空间，因此被保存在栈内存中；")]),t._v(" "),n("li",[t._v("引用类型值是对象，保存在堆内存中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。")])]),t._v(" "),n("h4",{attrs:{id:"标记清除"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[t._v("#")]),t._v(" 标记清除")]),t._v(" "),n("p",[t._v("标记清除(mark-and-sweep) 是 JavaScript 中最常用的垃圾回收方式。其执行机制如下：")]),t._v(" "),n("ul",[n("li",[t._v("当变量进入环境时（例如在函数中声明一个变量），就将其标记为“进入环境”")]),t._v(" "),n("li",[t._v("当变量离开环境时将其标记为“离开环境”")])]),t._v(" "),n("p",[t._v("逻辑上，永远不能释放进入环境的变量所占用的内存，因为执行流进入相应的环境时，可能会用到它们。\n标记变量的方式有很多种，可以使用标记位的形式记录变量进入环境，也可单独为“进入环境”和“离开环境”添加变量列表来记录变化。\n标记清除采用的收集策略为：")]),t._v(" "),n("ul",[n("li",[t._v("JavaScript 中的垃圾收集器运行时会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）；")]),t._v(" "),n("li",[t._v("然后去掉环境中的变量以及被环境中的变量引用的变量的标记；")]),t._v(" "),n("li",[t._v("此后，再被加上标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。")]),t._v(" "),n("li",[t._v("最后，垃圾收集器完成内存清除，销毁那些带标记的值并回收其占用的内存空间。")])]),t._v(" "),n("p",[t._v("2008 年之前，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript 实现使用的均为标记清除式的垃圾回收策略，区别可能在垃圾收集的时间间隔。")]),t._v(" "),n("h4",{attrs:{id:"引用计数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),n("p",[t._v("另一种不太常见的垃圾收集策略叫做引用计数。引用计数的额含义是跟踪记录每个值被引用的次数。")]),t._v(" "),n("ul",[n("li",[t._v("当声明一个变量并将一个引用类型值赋值给该变量时，这个值的引用次数为1；")]),t._v(" "),n("li",[t._v("若同一个值(变量)又被赋值给另一个变量，则该值的引用次数加1；")]),t._v(" "),n("li",[t._v("但是如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1；")]),t._v(" "),n("li",[t._v("当这个值的引用次数为 0 时，则无法再访问这个值，就可回收其占用的内存空间；")])]),t._v(" "),n("p",[t._v("垃圾收集器下次运行时，会释放那些引用次数为零的值所占用的内存。引用计数存在一个致命的问题：循环引用。循环引用是指，对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。下面的例子：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("problem")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" objectA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" objectB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  objectA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("someOtherObject "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectB\n  objectB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("anotherObject "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectA\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("上述例子中 objectA 和 objectB 通过各自属性相互引用。按照引用计数的策略，两个对象的引用次数均为 2。若采用标记清除策略，函数执行完毕，对象离开作用域就不存在相互引用。但采用引用计数后，函数执行完，两个对象的引用次数永不为 0，会一直存在内存中，若多次调用，导致大量内存得不到回收。")]),t._v(" "),n("p",[t._v("IE8 浏览器 之前中有一部分对象并不是原生的 JavaScript 对象，可能是使用 C++ 以 COM 对象的形式实现的(BOM, DOM)。而 COM 对象的垃圾收集机制采用的是引用计数策略。即使 IE 的 JavaScript 引擎是使用标记清除策略实现的，但 JavaScript 访问 COM 对象仍然是基于 引用计数策略的。在这种情况下，只要在 IE 中涉及 COM 对象，就可能存在循环引用的问题。为避免出现循环引用，最好在不使用这些对象时，手动断开原生 JavaScript 对象 与 DOM 元素之间的连接。IE 中的循环引用与手动断开的操作如下所示：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" element "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'some_element'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" myObject "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nmyObject"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("element "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" element\nelement"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("someObject "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" myObject\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以上 存在循环引用")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...... ")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以下 手动断开连接")]),t._v("\nmyObject"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("element "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\nelement"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("someObject "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n\n")])])]),n("h4",{attrs:{id:"性能问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性能问题"}},[t._v("#")]),t._v(" 性能问题")]),t._v(" "),n("p",[t._v("垃圾收集器是周期运行的，确定垃圾收集的时间间隔是个重要的问题。IE7 之前的垃圾收集器是根据内存分配量运行的，即 256 个变量、4096 个对象(数组)字面量或 64 KB 的字符串。达到这些临界值的任何一个，垃圾收集器就会运行。所以就导致如果一个脚本含有很多变量，在整个生命周期中一直保有前面临界值大小的变量，就会频繁触发垃圾回收，会存在严重的性能问题。IE7 重写了垃圾收集例程。新的工作方式为：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。初始值与之前版本相同，但如果垃圾收集例程回收的内存低于 15%，则临界值加倍。若回收内存分配量超过 85%，则临界值重置回默认值。")]),t._v(" "),n("h4",{attrs:{id:"管理内存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#管理内存"}},[t._v("#")]),t._v(" 管理内存")]),t._v(" "),n("p",[t._v("JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统奔溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。")]),t._v(" "),n("p",[t._v("因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的诗句。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用，这个做法叫做接触引用。这个做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用。如下面例子：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("createPerson")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" localPerson "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  localPerson"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" localPerson\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" globalPerson "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("createPerson")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Nicholas'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 手动解除 globalPerson 的引用")]),t._v("\nglobalPerson "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n")])])]),n("blockquote",[n("p",[t._v("解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾回收器下次运行时将其回收。")])]),t._v(" "),n("h3",{attrs:{id:"javascript-v8-引擎的垃圾回收机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-v8-引擎的垃圾回收机制"}},[t._v("#")]),t._v(" JavaScript V8 引擎的垃圾回收机制")]),t._v(" "),n("p",[t._v("在 JavaScript 脚本中，绝大多数对象的生存期很短，只有部分对象的生存期较长。所以，V8 中的垃圾回收主要使用的是 分代回收 (Generational collection)机制。")]),t._v(" "),n("h4",{attrs:{id:"分代回收机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分代回收机制"}},[t._v("#")]),t._v(" 分代回收机制")]),t._v(" "),n("p",[t._v("V8 引擎将保存对象的 堆 (heap) 进行了分代:")]),t._v(" "),n("ul",[n("li",[t._v("对象最初会被分在新生区(New Space) (1~8M)，新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理(小周期)，清理掉新生区中不再活跃的死对象。")]),t._v(" "),n("li",[t._v("对于超过 2 个小周期的对象，则需要将其移动至老生区(Old Space)。老生区在标记-清除或标记-紧缩的过程(大周期)中进行回收。")])]),t._v(" "),n("p",[t._v("大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。")]),t._v(" "),n("h4",{attrs:{id:"scavenge-算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#scavenge-算法"}},[t._v("#")]),t._v(" Scavenge 算法")]),t._v(" "),n("p",[t._v("由于垃圾清理发生的比较频繁，清理的过程必须很快。V8 中的清理过程使用的是 Scavenge 算法，按照经典的 Cheney 算法实现的。Scavenge 算法的主要过程是：")]),t._v(" "),n("ul",[n("li",[t._v("新生区被分为两个等大小的子区(semi-spaces)：to-space 和 from-space；")]),t._v(" "),n("li",[t._v("大多数的内存分配都是在 to-space 发生 (某些特定对象是在老生区)；")]),t._v(" "),n("li",[t._v("当 to-space 耗尽时，交换 to-space 和 from-space, 此时所有的对象都在 from-space；")]),t._v(" "),n("li",[t._v("然后将 from-space 中活跃的对象复制到 to-space 或者老生区中;")]),t._v(" "),n("li",[t._v("这些对象被直接压到 to-space，提升了 Cache 的内存局部性，可使内存分配简洁快速。")])]),t._v(" "),n("h4",{attrs:{id:"不能被忽视的写屏障-write-barriers"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不能被忽视的写屏障-write-barriers"}},[t._v("#")]),t._v(" 不能被忽视的写屏障 Write barriers")]),t._v(" "),n("p",[t._v("如果新生区有某个对象，只有一个指向它的指针，恰好该指针在老生区的对象中，在垃圾回收之前我们如何得知新生区的该对象是活跃的呢？为解决此问题，V8 在写缓冲区有一个列表，其中记录了所有老生区对象指向新生区的情况。新生区对象诞生时不会有指向它的指针，当老生区的对象出现指向新生区对象的指针时，便记录跨区指向，记录行为总是发生在写操作中。")]),t._v(" "),n("h4",{attrs:{id:"标记-清除算法-与-标记-紧缩算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法-与-标记-紧缩算法"}},[t._v("#")]),t._v(" 标记-清除算法 与 标记-紧缩算法")]),t._v(" "),n("p",[t._v("因为新生区的内存一般都不大，所以使用 Scavenge 算法进行垃圾回收效果比较好。老生区一般占用内存较大，因此采用的是 标记-清除(Mark-Sweep)算法 与 标记-紧缩(Mark-Compact)算法。两种算法都包括两个阶段：标记阶段，清除或紧缩阶段。")]),t._v(" "),n("h5",{attrs:{id:"标记阶段"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标记阶段"}},[t._v("#")]),t._v(" 标记阶段")]),t._v(" "),n("p",[t._v("在标记阶段，堆上所有的活跃对象都会被发现并且标记。")]),t._v(" "),n("ul",[n("li",[t._v("每一页都包含用来标记的位图")]),t._v(" "),n("li",[t._v("位图都要占据空间 (3.1% on 32-bit, 1.6% on 64-bit systems)")]),t._v(" "),n("li",[t._v("使用两位二进制标记对象的状态")]),t._v(" "),n("li",[t._v("状态为白(white), 它尚未被垃圾回收器发现")]),t._v(" "),n("li",[t._v("状态为灰(gray), 它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕")]),t._v(" "),n("li",[t._v("状态为黑(black), 它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕")])]),t._v(" "),n("p",[t._v("标记算法的核心是 深度优先搜索，具体过程为：")]),t._v(" "),n("ul",[n("li",[t._v("在标记的初期，位图是空的，所有对象也都是白的。\n从根可达的对象会被染色为灰色，并被放入标记用的一个单独分配的双端队列。")]),t._v(" "),n("li",[t._v("标记阶段的每次循环，GC会将一个对象从双端队列中取出，染色为黑，然后将它的邻接对象染色为灰，并把邻接对象放入双端队列。")]),t._v(" "),n("li",[t._v("这一过程在双端队列为空且所有对象都变黑时结束。")]),t._v(" "),n("li",[t._v("特别大的对象，如长数组，可能会在处理时分片，以防溢出双端队列。如果双端队列溢出了，则对象仍然会被染为灰色，但不会再被放入队列（这样他们的邻接对象就没有机会再染色了）。")]),t._v(" "),n("li",[t._v("因此当双端队列为空时，GC仍然需要扫描一次，确保所有的灰对象都成为了黑对象。对于未被染黑的灰对象，GC会将其再次放入队列，再度处理。")])]),t._v(" "),n("p",[t._v("标记算法结束后，所有的活跃对象都被染成黑色，所有的死对象仍是白的。下一步就可以清除或者紧缩了。")]),t._v(" "),n("h5",{attrs:{id:"清除-或-紧缩-算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#清除-或-紧缩-算法"}},[t._v("#")]),t._v(" 清除 或 紧缩 算法")]),t._v(" "),n("p",[t._v("标记算法执行后，可以选择清除 或是紧缩，这两个算法都可以收回内存，而且两者都作用于页级(V8 中的内存页是 1MB 的连续内存块)\n清除算法扫描连续存放的死对象，将其变为空闲空间，并将其添加到空闲内存链表中。清除算法只需要遍历页的位图，搜索连续的白对象。每一页都包含数个空闲内存链表，其分别代表小内存区（<256字）、中内存区（<2048字）、大内存区（<16384字）和超大内存区（其它更大的内存）]\n紧缩算法会尝试将对象从碎片页(包含大量小空闲内存的页)中迁移整合在一起，来释放内存。这些对象会被迁移到另外的页上，因此也可能会新分配一些页。而迁出后的碎片页就返还给操作系统。")]),t._v(" "),n("p",[t._v("紧缩算法会尝试将对象从碎片页(包含大量小空闲内存的页)中迁移整合在一起，来释放内存。这些对象会被迁移到另外的页上，因此也可能会新分配一些页。而迁出后的碎片页就返还给操作系统")]),t._v(" "),n("p",[t._v("对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块其它页的区域，将该对象复制至新页，并在碎片页中的该对象上写上转发地址。\n迁出过程中，对象中的旧地址会被记录下来，这样在迁出结束后V8会遍历它所记录的地址，将其更新为新的地址。由于标记过程中也记录了不同页之间的指针，此时也会更新这些指针的指向。")]),t._v(" "),n("h4",{attrs:{id:"增量标记-与-惰性清除"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#增量标记-与-惰性清除"}},[t._v("#")]),t._v(" 增量标记 与 惰性清除")]),t._v(" "),n("p",[t._v("对于一个堆很大，活跃对象有很多的脚本时，标记-清除 与 标记-紧缩 的效率可能会很慢，为减少垃圾回收引起的停顿，引入了增量标记(Incremental marking) 和惰性清理(lazy sweeping)。增量标记允许堆的标记(前面的标记阶段)发生在几次5-10毫秒的小停顿中。增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。就像普通的标记一样，增量标记也是一个深度优先搜索，并同样采用白灰黑机制来分类对象。增量标记与普通标记的区别是，添加了从黑对象到白对象的指针，为此需要再次启用写屏障中，在记录 老->新 的同时，记录 黑->白。在进行清除时，一旦在写屏障中发现这样的指针，黑对象会被重新染色为灰对象，重新放回到双端队列中。惰性清理是指在标记完成后，并不急着释放空间，无需一次清理所有的页，垃圾回收器会视情况逐一清理，直到所有页都清理完成。\n余下的涉及垃圾回收原理的部分留着后面继续整理。(平行标记 与 并发标记)")])])}),[],!1,null,null,null);a.default=r.exports}}]);