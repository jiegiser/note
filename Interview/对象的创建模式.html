<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>理解对象 | 学习笔记</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="学习笔记">
    <link rel="preload" href="/note/assets/css/0.styles.c9d983ba.css" as="style"><link rel="preload" href="/note/assets/js/app.f48e3c9b.js" as="script"><link rel="preload" href="/note/assets/js/2.acebdf5a.js" as="script"><link rel="preload" href="/note/assets/js/17.d0080e19.js" as="script"><link rel="prefetch" href="/note/assets/js/10.7ebceb37.js"><link rel="prefetch" href="/note/assets/js/100.f88afc8f.js"><link rel="prefetch" href="/note/assets/js/101.a6faaf18.js"><link rel="prefetch" href="/note/assets/js/102.d7be220c.js"><link rel="prefetch" href="/note/assets/js/103.cc709495.js"><link rel="prefetch" href="/note/assets/js/104.1df96540.js"><link rel="prefetch" href="/note/assets/js/105.3173bdb4.js"><link rel="prefetch" href="/note/assets/js/106.5eb1d73e.js"><link rel="prefetch" href="/note/assets/js/107.afd76c09.js"><link rel="prefetch" href="/note/assets/js/108.9c7d3e5e.js"><link rel="prefetch" href="/note/assets/js/109.26b8a916.js"><link rel="prefetch" href="/note/assets/js/11.db8f823f.js"><link rel="prefetch" href="/note/assets/js/110.387c8fc8.js"><link rel="prefetch" href="/note/assets/js/111.901a5c23.js"><link rel="prefetch" href="/note/assets/js/12.26a6a41a.js"><link rel="prefetch" href="/note/assets/js/13.7d8efc0e.js"><link rel="prefetch" href="/note/assets/js/14.d8ba7e58.js"><link rel="prefetch" href="/note/assets/js/15.9f96d192.js"><link rel="prefetch" href="/note/assets/js/16.cf126cf5.js"><link rel="prefetch" href="/note/assets/js/18.abec5027.js"><link rel="prefetch" href="/note/assets/js/19.60758d73.js"><link rel="prefetch" href="/note/assets/js/20.4d8980d7.js"><link rel="prefetch" href="/note/assets/js/21.7a284c31.js"><link rel="prefetch" href="/note/assets/js/22.f5272d7e.js"><link rel="prefetch" href="/note/assets/js/23.0c154d57.js"><link rel="prefetch" href="/note/assets/js/24.80a6fffa.js"><link rel="prefetch" href="/note/assets/js/25.f0a5d61a.js"><link rel="prefetch" href="/note/assets/js/26.9ba5b107.js"><link rel="prefetch" href="/note/assets/js/27.f6490b13.js"><link rel="prefetch" href="/note/assets/js/28.9e209cee.js"><link rel="prefetch" href="/note/assets/js/29.e3fb8d0d.js"><link rel="prefetch" href="/note/assets/js/3.02a2e74e.js"><link rel="prefetch" href="/note/assets/js/30.72f910ab.js"><link rel="prefetch" href="/note/assets/js/31.dc64b847.js"><link rel="prefetch" href="/note/assets/js/32.e30a94cb.js"><link rel="prefetch" href="/note/assets/js/33.cc8d953d.js"><link rel="prefetch" href="/note/assets/js/34.1cf50e1a.js"><link rel="prefetch" href="/note/assets/js/35.d0698259.js"><link rel="prefetch" href="/note/assets/js/36.2b9439c4.js"><link rel="prefetch" href="/note/assets/js/37.04520d6d.js"><link rel="prefetch" href="/note/assets/js/38.21ad0da5.js"><link rel="prefetch" href="/note/assets/js/39.7c1ec5ae.js"><link rel="prefetch" href="/note/assets/js/4.50c7efde.js"><link rel="prefetch" href="/note/assets/js/40.677cce3e.js"><link rel="prefetch" href="/note/assets/js/41.ce20fece.js"><link rel="prefetch" href="/note/assets/js/42.45131930.js"><link rel="prefetch" href="/note/assets/js/43.c00dbde3.js"><link rel="prefetch" href="/note/assets/js/44.78e6df43.js"><link rel="prefetch" href="/note/assets/js/45.9bb212b8.js"><link rel="prefetch" href="/note/assets/js/46.1851b5af.js"><link rel="prefetch" href="/note/assets/js/47.a96f7552.js"><link rel="prefetch" href="/note/assets/js/48.3e0e73e9.js"><link rel="prefetch" href="/note/assets/js/49.654c402a.js"><link rel="prefetch" href="/note/assets/js/5.2761c189.js"><link rel="prefetch" href="/note/assets/js/50.0ed318c4.js"><link rel="prefetch" href="/note/assets/js/51.3ae7bfc2.js"><link rel="prefetch" href="/note/assets/js/52.6c1678f0.js"><link rel="prefetch" href="/note/assets/js/53.c351ae4d.js"><link rel="prefetch" href="/note/assets/js/54.df8e0a2b.js"><link rel="prefetch" href="/note/assets/js/55.2716f864.js"><link rel="prefetch" href="/note/assets/js/56.f0e895c3.js"><link rel="prefetch" href="/note/assets/js/57.994f5e14.js"><link rel="prefetch" href="/note/assets/js/58.65181c21.js"><link rel="prefetch" href="/note/assets/js/59.6f93449f.js"><link rel="prefetch" href="/note/assets/js/6.1a9d586b.js"><link rel="prefetch" href="/note/assets/js/60.77b55c41.js"><link rel="prefetch" href="/note/assets/js/61.999e9ce3.js"><link rel="prefetch" href="/note/assets/js/62.3c7c452d.js"><link rel="prefetch" href="/note/assets/js/63.3ba70471.js"><link rel="prefetch" href="/note/assets/js/64.3a6772bd.js"><link rel="prefetch" href="/note/assets/js/65.0444b423.js"><link rel="prefetch" href="/note/assets/js/66.242b50d9.js"><link rel="prefetch" href="/note/assets/js/67.6d8af678.js"><link rel="prefetch" href="/note/assets/js/68.6377784d.js"><link rel="prefetch" href="/note/assets/js/69.dc616a70.js"><link rel="prefetch" href="/note/assets/js/7.30cff58b.js"><link rel="prefetch" href="/note/assets/js/70.fe9f09a0.js"><link rel="prefetch" href="/note/assets/js/71.846e247c.js"><link rel="prefetch" href="/note/assets/js/72.4b95d2c6.js"><link rel="prefetch" href="/note/assets/js/73.ce5019ad.js"><link rel="prefetch" href="/note/assets/js/74.1d0aa2fb.js"><link rel="prefetch" href="/note/assets/js/75.fbe7b373.js"><link rel="prefetch" href="/note/assets/js/76.792268ac.js"><link rel="prefetch" href="/note/assets/js/77.374994a7.js"><link rel="prefetch" href="/note/assets/js/78.3b70e68c.js"><link rel="prefetch" href="/note/assets/js/79.f2e7d7c9.js"><link rel="prefetch" href="/note/assets/js/8.c70a09ea.js"><link rel="prefetch" href="/note/assets/js/80.b39f2c54.js"><link rel="prefetch" href="/note/assets/js/81.4d4a0e1a.js"><link rel="prefetch" href="/note/assets/js/82.83a7d07d.js"><link rel="prefetch" href="/note/assets/js/83.8af5e5d5.js"><link rel="prefetch" href="/note/assets/js/84.8b82b8fb.js"><link rel="prefetch" href="/note/assets/js/85.9f744da7.js"><link rel="prefetch" href="/note/assets/js/86.a0e26e36.js"><link rel="prefetch" href="/note/assets/js/87.fd632993.js"><link rel="prefetch" href="/note/assets/js/88.a4898682.js"><link rel="prefetch" href="/note/assets/js/89.67269208.js"><link rel="prefetch" href="/note/assets/js/9.575c7b0f.js"><link rel="prefetch" href="/note/assets/js/90.48845af1.js"><link rel="prefetch" href="/note/assets/js/91.fad42817.js"><link rel="prefetch" href="/note/assets/js/92.b14ca363.js"><link rel="prefetch" href="/note/assets/js/93.193bbfa6.js"><link rel="prefetch" href="/note/assets/js/94.eab23838.js"><link rel="prefetch" href="/note/assets/js/95.fc661b1d.js"><link rel="prefetch" href="/note/assets/js/96.606fba7a.js"><link rel="prefetch" href="/note/assets/js/97.07c73745.js"><link rel="prefetch" href="/note/assets/js/98.fdf1ac44.js"><link rel="prefetch" href="/note/assets/js/99.831f32b0.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.c9d983ba.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/note/css/css基础.html" class="nav-link">
  css 相关
</a></div><div class="nav-item"><a href="/note/react/react基础.html" class="nav-link">
  react 相关
</a></div><div class="nav-item"><a href="/note/js-patterns/代理模式.html" class="nav-link">
  js 设计模式
</a></div><div class="nav-item"><a href="/note/typescript/typescript基础语法.html" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/note/node/基础知识.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/note/javascript/知识体系.html" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/note/vue/相关笔记.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/note/webpack/基础知识.html" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/note/webgis/坐标系相关.html" class="nav-link">
  webgis
</a></div><div class="nav-item"><a href="/note/http/HTTP协议基础.html" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="nav-link">
  Interview
</a></div><div class="nav-item"><a href="/note/gisAlgorithm/数据结构-矢量.html" class="nav-link">
  gis 算法
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/note/css/css基础.html" class="nav-link">
  css 相关
</a></div><div class="nav-item"><a href="/note/react/react基础.html" class="nav-link">
  react 相关
</a></div><div class="nav-item"><a href="/note/js-patterns/代理模式.html" class="nav-link">
  js 设计模式
</a></div><div class="nav-item"><a href="/note/typescript/typescript基础语法.html" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/note/node/基础知识.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/note/javascript/知识体系.html" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/note/vue/相关笔记.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/note/webpack/基础知识.html" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/note/webgis/坐标系相关.html" class="nav-link">
  webgis
</a></div><div class="nav-item"><a href="/note/http/HTTP协议基础.html" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="nav-link">
  Interview
</a></div><div class="nav-item"><a href="/note/gisAlgorithm/数据结构-矢量.html" class="nav-link">
  gis 算法
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="sidebar-link">forEach、for in、for of、map之间的区别</a></li><li><a href="/note/Interview/数据类型.html" class="sidebar-link">数据类型</a></li><li><a href="/note/Interview/操作符.html" class="sidebar-link">操作符</a></li><li><a href="/note/Interview/变量、作用域和内存.html" class="sidebar-link">变量、作用域和内存</a></li><li><a href="/note/Interview/引用类型.html" class="sidebar-link">引用类型</a></li><li><a href="/note/Interview/对象的创建模式.html" class="active sidebar-link">对象的创建模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#理解对象" class="sidebar-link">理解对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#属性类型" class="sidebar-link">属性类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#创建对象" class="sidebar-link">创建对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#工厂模式" class="sidebar-link">工厂模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#构造函数模式" class="sidebar-link">构造函数模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#原型模式" class="sidebar-link">原型模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#组合使用构造函数模式和原型模式（最常用的模式）" class="sidebar-link">组合使用构造函数模式和原型模式（最常用的模式）</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#动态原型模式" class="sidebar-link">动态原型模式</a></li></ul></li></ul></li><li><a href="/note/Interview/继承.html" class="sidebar-link">继承</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="理解对象"><a href="#理解对象" class="header-anchor">#</a> 理解对象</h2> <h3 id="属性类型"><a href="#属性类型" class="header-anchor">#</a> 属性类型</h3> <p>ECMAScript 中有两种属性：数据属性和访问器属性。</p> <h4 id="数据属性"><a href="#数据属性" class="header-anchor">#</a> 数据属性</h4> <p>包含一个数据值的位置，在这个位置可以读取和写入值。</p> <ul><li>[[Configurable]]: 表示能否通过 delete 删除属性，修改属性的特性，或者能否把属性修改为访问器属性，默认为 true；</li> <li>[[Enmuerable]]: 表示能否通过 for-in 循环返回属性，默认为 true；</li> <li>[[Writable]]: 表示能否修改属性的值，默认为 true；</li> <li>[[Value]]：表示这个属性的值。比如定义一个 perosn 对象，他的 name 属性为 jie，那么他的 [[Value]] 存放的是 jie，默认为 undefined；</li></ul> <p>要修改属性默认的特性，必须使用ecma5中的object.definePropery()方法；该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中描述符对象的属性必须是 configurable、enumerable、writable 和 value。设置其中的一个或者多个值，可以修改对应的属性值。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">let</span> person<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 表示 name 属性是只读的</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    writable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 表示不能修改属性的值</span>
    value<span class="token operator">:</span> <span class="token string">'jiegiser'</span><span class="token punctuation">,</span> <span class="token comment">// 赋值属性值为 jiegiser</span>
    configurable<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">// 表示不能通过 delete 删除属性</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
  person<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;jieouba&quot;</span> <span class="token comment">// 在严格模式下会报错</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 修改不成功，还是 jiegiser</span>
  <span class="token keyword">delete</span> person<span class="token punctuation">.</span>name
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token comment">// 删除不成功</span>
</code></pre></div><p>这里需要注意的是，如果一但通过 defineProperty 改变了 configurable 为不可配置，那么就不能再把它变回可配置；调用 Object.defineProperty方 法修改除了 writable之外的特性都会报错，抛出异常 Cannot redefine property: name</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    configurable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    value<span class="token operator">:</span> <span class="token string">'jiegiser'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      value<span class="token operator">:</span> <span class="token string">'jieouba'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>也就是说可以多次调用 Object.defineProperty 方法修改同一个属性，但是在把 configurable 特性设置为 false 之后，就会有限制；如果调用 Object.defineProperty 方法只是修改已定义的属性的特性，则无此限制。建议不要在 IE8 中使用，会有问题-不完善；</p> <blockquote><p>使用 Object.defineProperty 方法创建一个新的属性时，如果不指定 configurable、writable、enumerable 值，默认是 false。</p></blockquote> <h4 id="访问器属性"><a href="#访问器属性" class="header-anchor">#</a> 访问器属性</h4> <p>不包含数据值，他们包含一对getter很setter函数（不过这两个函数都不是必须的）在读取访问器属性是，就会调用 getter 方法；这个函数赋值返回有效的值，在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。</p> <ul><li>[[Configurable]]：表示能否通过 delete 删除属性，修改属性的特性，或者能否把属性修改为数据属性；对于直接在对象上定义的属性，这个特性的默认值为 true；</li> <li>[[Enmuerable]]：表示能否通过 for-in 循环返回属性；在对象上定义的属性，该特性默认值为 true；</li> <li>[[Get]]：在读取属性时调用该函数；默认值为 undefined；</li> <li>[[Set]]：在写入属性时调用该函数；默认值为 undefined；</li></ul> <p>访问器属性不能直接定义，必须使用 object.definePropery() 方法：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">let</span> book<span class="token operator">=</span> <span class="token punctuation">{</span>
      _year<span class="token operator">:</span> <span class="token number">2019</span><span class="token punctuation">,</span> <span class="token comment">// 下划线表示只能通过对象方法访问</span>
      edition<span class="token operator">:</span><span class="token number">1</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 访问器</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不一定非要同时指定 getter 与 setter，只制定 getter 意味着属性是不能写的，尝试写入属性会被忽略，在严格模式会报错</span>
    <span class="token comment">// 只指定 setter 函数的属性也不能读，在非严格模式会返回 undefined，在严格模式会抛出异常</span>
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>newValue<span class="token operator">&gt;</span><span class="token number">2019</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token operator">=</span>newValue
        <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2019</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  book<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2020</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span>
</code></pre></div><h4 id="定义多个属性"><a href="#定义多个属性" class="header-anchor">#</a> 定义多个属性</h4> <p>使用 Object.defineProperties() 方法，可以利用这个方法通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// 为对象定义多个属性</span>
    <span class="token keyword">let</span> book<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span><span class="token punctuation">{</span>
        _year<span class="token operator">:</span><span class="token punctuation">{</span>
            writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            value<span class="token operator">:</span> <span class="token number">2019</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        edition<span class="token operator">:</span><span class="token punctuation">{</span>
            writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            value<span class="token operator">:</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">// 访问器属性</span>
        year<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token keyword">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2019</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue
                    <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2019</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    book<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2020</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span>
</code></pre></div><h4 id="读取属性的特性"><a href="#读取属性的特性" class="header-anchor">#</a> 读取属性的特性</h4> <p>Object.getOwnPropertyDescriptor() 方法可以取得给定属性的描述符，他包含两个参数为：属性所在的对象和要读取其描述符的属性名称，返回一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set 如果是数据属性，这个对象属性有 configurable、enumberable、writable、和 value：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      _year<span class="token operator">:</span> <span class="token punctuation">{</span>
          value<span class="token operator">:</span> <span class="token number">2019</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      edition<span class="token operator">:</span> <span class="token punctuation">{</span>
          value<span class="token operator">:</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      year<span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token keyword">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2019</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
                  <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2019</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> decriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">'_year'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>decriptor<span class="token punctuation">)</span> <span class="token comment">// {value: 2019, writable: false, enumerable: false, configurable: false}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> decriptor<span class="token punctuation">.</span>get<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
  <span class="token keyword">const</span> descriptorYear <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>descriptorYear<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {get: ƒ, set: ƒ, enumerable: false, configurable: false}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>descriptorYear<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> descriptorYear<span class="token punctuation">.</span>get<span class="token punctuation">)</span> <span class="token comment">// function</span>
  <span class="token comment">// 在 javascript 中,对于 DOM 以及 BOM 都可以使用 getOwnPropertyDescriptor() 方法</span>
</code></pre></div><h2 id="创建对象"><a href="#创建对象" class="header-anchor">#</a> 创建对象</h2> <h3 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h3> <ul><li>产生的原因：使用同一个接口创建很多对象，会产生大量的重复的代码，为了解决这个问题，</li> <li>工厂模式：该模式抽象了创建具体对象的过程，考虑到在 ECMAscript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job<span class="token punctuation">}</span>
      <span class="token keyword">return</span> o
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> jiegiser <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'jiegiser'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'giser'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> jieouba <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'jieouba'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'junren'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jiegiser<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jieouba<span class="token punctuation">)</span>
</code></pre></div><p>工厂对象虽然解决了创建多个相同对象的问题，但是没有解决对象识别的问题，也就是怎么知道一个对象的类型</p> <h3 id="构造函数模式"><a href="#构造函数模式" class="header-anchor">#</a> 构造函数模式</h3> <p>上面的例子可以这样写：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jiegiser'</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">'IT'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jieouba'</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">'giser'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span> <span class="token comment">// Person {name: &quot;jiegiser&quot;, age: 18, job: &quot;IT&quot;, sayName: ƒ}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment">// Person {name: &quot;jieouba&quot;, age: 18, job: &quot;giser&quot;, sayName: ƒ}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token operator">===</span> person2<span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>可以发现跟上面不同的是，没有显示的创建对象，直接将属性和方法赋值给了对象，没有 return 语句；还有就是 Person 的 P 是大写，按照规定构造函数始终都应该以一个大写字母开头，而非构造函数的那么使用小写字母进行书写；这里注意，构造函数本身也是构造函数，只不过可以用来创建对象而已；要创建 person 实例，必须要使用 new 关键字进行创建，创建一个实例，其实是以下四个步骤：</p> <blockquote><p>使用 new 关键字创建一个实例，经历以下步骤：</p></blockquote> <ol><li>创建一个新对象；</li> <li>将构造函数的作用域赋给新对象；</li> <li>执行构造函数中的代码（为这个新对象添加属性）；</li> <li>返回新对象</li></ol> <p>需要注意的是，person1 和 person2 分别保存着 Peroson 的一个不同的实例，这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token comment">// 对象的 constructor 属性是用来标识对象类型的，我们创建的所有对象，既是 Object 的实例，同时也是 Person 的实例：</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，而这个正是构造函数模式胜过工厂模式的地方。上面的例子中 person1 和 peroson2 之所以同时是Object 的实例，是因为所有对象均继承 object；
构造函数与其他函数的唯一区别就是需要用 new，但是任何函数，只要通过 new 操作符来调用，那他就可以作为构造函数，如果任何函数不使用 new 来调用，那他跟普通函数没什么区别；
例如前面的例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当做构造函数使用</span>
<span class="token keyword">const</span> person1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jiegiser'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'IT'</span><span class="token punctuation">)</span> <span class="token comment">// Person {name: &quot;jiegiser&quot;, age: 18, job: &quot;IT&quot;, sayName: ƒ}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span>
<span class="token comment">// 当做普通函数使用</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'jieouba'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'giser'</span><span class="token punctuation">)</span>
window<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 在另一个对象的作用域中调用</span>
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'jie'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'giser'</span><span class="token punctuation">)</span> <span class="token comment">// 执行了 new 操作符，没有将属性挂在到全局，this 执行 o 对象。</span>
o<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>构造函数的问题：就是每一个方法都要在每个实例上重新创建一遍，比如说我们前面的例子，sayName 方法，其实在每次实例化对象的时候，都会创建一次；
他实际执行的如下的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job
  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;console.log(this.name)&quot;</span><span class="token punctuation">)</span>  
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jiegiser'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'IT'</span><span class="token punctuation">)</span> <span class="token comment">// Person {name: &quot;jiegiser&quot;, age: 18, job: &quot;IT&quot;, sayName: ƒ}</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jieouba'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'giser'</span><span class="token punctuation">)</span> <span class="token comment">// Person {name: &quot;jieouba&quot;, age: 18, job: &quot;giser&quot;, sayName: ƒ}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span>
</code></pre></div><p>但是如果我们将 Person 的 sayName 方法转移到构造函数外，像下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job
  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> sayName
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样一来，由于 sayName 包含的是一个指向函数的指针，因此 person1 与 perosn2 就共享了在全局作用域中定义的同一个 sayName 函数，这样确实解决了
两个函数做了同一件是的问题，但是，在全局作用域中定义的函数实际上只能被没有对象调用，这让全局作用域有点名不副实，而且，如果对象需要定义很多
方法，那么就要定义很多个全局函数，那么我们这个自定义的引用类型就丝毫没有封装性可言了。可以使用原型模式来解决这个问题；</p> <h3 id="原型模式"><a href="#原型模式" class="header-anchor">#</a> 原型模式</h3> <p>我们创建的每一个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途就是包含可以由特定类型的所有实例共享的属性和方法。按照字面理解 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象，使用原型对象的好处是可以让所有对象共享它所包含的属性和方法，换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jiegiser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'giser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>
  <span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jieouba'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span>
  person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> perosn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  perosn2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName<span class="token operator">==</span>perosn2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>可以看到构造函数变成了变成看空对象；</p> <h4 id="原型对象"><a href="#原型对象" class="header-anchor">#</a> 原型对象</h4> <p>无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认的情况下，所有原型对象都会自动获取一个 constructor（构造函数）属性，这个属性是一个指向 prototype 属性所在函数的指针。比如前面的例子 Person.prototype.constructor 指向 Person，而通过这个构造函数，我们还可以继续为原型对象添加其他属性和方法。创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性，至于其他方法，都是从 Object 继承而来，当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。</p> <blockquote><p>需要注意的是，当调用构造函数创建一个新实例后，该实例的内部将包含一个指针__prpto__ ，指向构造函数的原型对象；这个连接存在与实例与构造函数的原型对象之间，而不是实例与构造函数之间；</p></blockquote> <p>下图是上面代码为例，展示各个对象之间的关系：</p> <p><img src="/note/assets/img/prototype.d084c7b6.png" alt="在这里插入图片描述"></p> <p>理一遍思路：首先构造函数有一个 prototype 指向的是原型对象，而原型对象的 constructor 指向的是 prototype 属性所在的函数，也就是构造函数；构造函数的默认属性是有一个 constructor 的指向的是 prototype 属性所在的函数，比如我们的 Person，我们后来为他的原型对象又加了name，age 等属性，其实 prototype 就是构造函数的原型对象；然后实例化后的对象有一个__proto__ 属性，指向的是构造函数的原型，而构造函数原型对象的 constructor 属性指向的是构造函数本身；</p> <blockquote><p>这里需要记住一句话：与构造函数没有直接的关系，他们都是构造函数原型对象之间的关系。</p></blockquote> <p>如果不存在__proto__ 属性可以通过 isProtoypeOf() 方法来确定对象之间是够存在这种关系；如果__proto__ 属性指向调用 isPrototypeOf 方法的对象（Person.prototype），那么这个方法就返回true；</p> <div class="language-js extra-class"><pre class="language-js"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true, 也就是说，看 person1 这个对象是否调用了 Person.prototype。</span>
  <span class="token comment">// 对象有一个方法 getPrototypeOf 方法，会返回对象的 __proto__ 属性；</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {name: &quot;jiegiser&quot;, age: 18, job: &quot;giser&quot;, sayName: ƒ, constructor: ƒ}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span> <span class="token operator">===</span> person1<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>这里需要注意的是，每当代码读取某个对象的属性时，都会执行一次搜索，目标是具有给定名字的属性，首先从实例本身开始，如果在实例中找到了具有给定名字的属性，那么返回该属性值，如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回，例如上面的 person1.sayName()，会先后执行两次搜索，首先会从 person1 的实例进行搜索，如果没有就从 person1 的原型进行搜索。</p> <p>需要注意的是，我们不能够通过对象的实例来重写原型中的值，如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性就会屏蔽原型中的那个属性。即使是一个 null，也会屏蔽比如下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jiegiser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'giser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> perosn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  perosn1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jieouba'</span> <span class="token comment">// Person {name: &quot;jieouba&quot;}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">)</span>
</code></pre></div><p>不过使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。
例如下面的代码</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jiegiser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'giser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> perosn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  perosn1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jieouba'</span> <span class="token comment">// Person {name: &quot;jieouba&quot;}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">)</span> <span class="token comment">// Person {name: &quot;jieouba&quot;}</span>
  <span class="token keyword">delete</span> perosn1<span class="token punctuation">.</span>name
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// jiegiser 读取原型上的属性</span>
</code></pre></div><p>使用 hasOwnProperty 方法可以检测一个属性是存在于实例中，还是存在与原型中。需要注意的是这个方法是从 Object 中继承来的，只在给定属性存在于对象实例中时，才会返回 true，例子如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jiegiser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'giser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> perosn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// perosn1.name='jieouba' // Person {name: &quot;jieouba&quot;}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false，不是来自实例属性</span>
</code></pre></div><p>通过 hasOwnProperty 方法可以检测什么时候访问的是实例属性什么时候访问原型属性就很清楚了。</p> <blockquote><p>这里需要注意的是，Object.getOwnPropertyDescriptor() 方法只能用于实例属性。要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor() 方法</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// { value: &quot;Person&quot;, writable: false, enumerable: false, configurable: true }</span>
</code></pre></div><h4 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="header-anchor">#</a> 原型与 in 操作符</h4> <p>有两种方法使用 in 操作符：单独使用和 for-in 循环中，单独使用时，in 会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jiegiser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'giser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> perosn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false--不是实例属性</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'name'</span> <span class="token keyword">in</span> perosn1<span class="token punctuation">)</span> <span class="token comment">// true----只要能够访问到 name，就是 true，不管该属性是在原型中还是在实例中</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">)</span>
</code></pre></div><p>同时使用 hasOwnProperty 以及 in 方法就可以进行判断该属性到底是在对象中还是在原型中：
hasOwnProperty 方法如果是实例属性的就返回 true，不是就返回 false；如果是实例属性定义的，那么返回 true</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">hasPrototypeProperty</span><span class="token punctuation">(</span><span class="token parameter">object<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 属性不是对象中的且属性存在与对象中，也就是判断一个属性；如果是实例属性返回 false，如果是原型对象属性，返回 true</span>
    <span class="token keyword">return</span> <span class="token operator">!</span>object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>name <span class="token keyword">in</span> object<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>   
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">hasPrototypeProperty</span><span class="token punctuation">(</span>perosn1<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>要取得对象上所有可以枚举的<code>实例属性</code>，可以使用 Object.keys() 方法，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组:</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jiegiser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'giser'</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span> <span class="token comment">// [&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]</span>
  <span class="token keyword">const</span> pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  pi<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Rob'</span>
  pi<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">23</span>
  <span class="token keyword">const</span> pik <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span> <span class="token comment">// 获取到可枚举的实例属性</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pik<span class="token punctuation">)</span> <span class="token comment">// [&quot;name&quot;, &quot;age&quot;]</span>

  <span class="token comment">// 如果想要得到所有实例属性，无论他是否可枚举，都可以使用Object.getOwnPropertyNames()方法，例子如下：</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [&quot;name&quot;, &quot;age&quot;]</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>pi<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]</span>

</code></pre></div><h4 id="更简单的原型语法"><a href="#更简单的原型语法" class="header-anchor">#</a> 更简单的原型语法</h4> <p>从前面的例子可以看到，每次给对象的原型对象定义属性时，都需要输入 .prototype，很麻烦，可以使用对象字面量的方法，来重写整个原型对象；如下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'jiegiser'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">'giser'</span><span class="token punctuation">,</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的写法有一个例外就是，constructor 构造函数属性不在指向 Person 了，前面曾今介绍过，每创建一个函数，就会用时创建它的 prototype，这个对象也会自动获取constructor 属性；而我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，因此他的原型对象的 constructor 属性也就变成了新对象的 constructor 属性（指向了 Object 构造函数），不再指向 Person 函数，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了；如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token comment">// true</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span> <span class="token comment">// false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend<span class="token punctuation">)</span>
</code></pre></div><p>如果在我们的开发中，constructor 的值真的很重要，可以通过下面这样特意将它设置回适当的值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">'jiegiser'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">'giser'</span><span class="token punctuation">,</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]</span>
<span class="token keyword">const</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>但是需要注意的是，以这种方式重设 constructor 属性，会导致他的 [[Enumberable]] 特性设置为 true，默认情况下，原生的 constructor 属性是不可以枚举的;
因此也可以使用 defineProperty 方法进行设置 constructor 属性，如下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'jiegiser'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    job<span class="token operator">:</span> <span class="token string">'giser'</span><span class="token punctuation">,</span>
    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 重置构造函数</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'constructor'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerbale<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    value<span class="token operator">:</span> Person
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="原型的动态性"><a href="#原型的动态性" class="header-anchor">#</a> 原型的动态性</h4> <p>也就是说在原型中查找值的过程是一次搜索，如果我们对原型对象做任何修改都能够立即从实例上反映出来，即使先创建了实例后修改原型也照样如此：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  friend<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// hi(没有问题)</span>
</code></pre></div><p>尽管可以修改原型添加属性以及方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了，我们知道，调用构造函数时，会为实例添加一个指向最初原型__proto__ 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系；这里需要注意的是实例中的指针指向的是原型，而不是指向构造函数：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">const</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token string">'jiegiser'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    job<span class="token operator">:</span> <span class="token string">'giser'</span><span class="token punctuation">,</span>
    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  friend<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// friend.sayName is not a function,因为 Friend 指向的原型中不包含以改名字命名的属性。</span>
</code></pre></div><p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型。这里的 Person 的 prototype 指向了 new Perosn prototype；而 friend 的 prototype 指向的是原来的 Person prototy。</p> <h4 id="原型对象的问题"><a href="#原型对象的问题" class="header-anchor">#</a> 原型对象的问题</h4> <p>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值，虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题，原型模式的最大问题是由其共享的本性所导致的。原型中所有属性是被很多实例共享的，这种共享对于函数非常合适，对于那些包含基本值的属性倒也说的过去，毕竟(去前面的例子)，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性，然而，对于包含引用类型值的属性来说，问题就比较突出了。比如下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">const</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token string">'jiegiser'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    friend<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'gao'</span><span class="token punctuation">,</span><span class="token string">'qi'</span><span class="token punctuation">,</span><span class="token string">'zhang '</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    job<span class="token operator">:</span> <span class="token string">'giser'</span><span class="token punctuation">,</span>
    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> perosn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  person1<span class="token punctuation">.</span>friend<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'huang'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friend<span class="token punctuation">)</span> <span class="token comment">// [&quot;gao&quot;, &quot;qi&quot;, &quot;zhang &quot;, &quot;huang&quot;]</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn2<span class="token punctuation">.</span>friend<span class="token punctuation">)</span> <span class="token comment">// [&quot;gao&quot;, &quot;qi&quot;, &quot;zhang &quot;, &quot;huang&quot;]</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friend <span class="token operator">===</span> perosn2<span class="token punctuation">.</span>friend<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="组合使用构造函数模式和原型模式（最常用的模式）"><a href="#组合使用构造函数模式和原型模式（最常用的模式）" class="header-anchor">#</a> 组合使用构造函数模式和原型模式（最常用的模式）</h3> <p>也正是由于上面的问题，所以很少有人单独使用原型模式，而大部分使用组合的模式；创建自定义类型的最常见的方式，就是组合使用构造函数模式与原型模式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样，每个实例都会用自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数,可谓是集两种模式之长,如下面的代码,重写了上面的例子:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job
  <span class="token keyword">this</span><span class="token punctuation">.</span>friend <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'jie'</span><span class="token punctuation">,</span><span class="token string">'huang'</span><span class="token punctuation">,</span><span class="token string">'gao'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jiegiser'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'giser'</span><span class="token punctuation">,</span> <span class="token string">'zhang'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> perosn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jieouba'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'gou'</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span>friend<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'qi'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friend<span class="token punctuation">)</span> <span class="token comment">// [&quot;jie&quot;, &quot;huang&quot;, &quot;gao&quot;, &quot;qi&quot;]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>perosn2<span class="token punctuation">.</span>friend<span class="token punctuation">)</span> <span class="token comment">// [&quot;jie&quot;, &quot;huang&quot;, &quot;gao&quot;]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friend <span class="token operator">===</span> perosn2<span class="token punctuation">.</span>friend<span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> perosn2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>上面的例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法 sayName 则是在原型中定义的，而修改了 person1.friend ,并不会影响到 person2.friend，因为他们分别引用了不同的数组。</p> <h3 id="动态原型模式"><a href="#动态原型模式" class="header-anchor">#</a> 动态原型模式</h3> <p>动态原型模式是把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的优点；换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型，比如下面的例子:</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job
    <span class="token comment">// 方法</span>
    <span class="token comment">// 如果 sayName 方法不存在，就添加到原型中，这段代码只会在初次调用构造函数才会执行，此后，原型已经完成初始化，不需要在做什么修改了</span>
    <span class="token comment">// 这里需要注意的是，这里对原型所做的修改，能够立即在所有实例中得到反映。需要注意的是，if 预计检查的可以是初始化之后应该存在的任何属性或方法</span>
    <span class="token comment">// 不必用一大堆 if 语句检查每个属性和每个方法，只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用 instanceof 操作符确定他的类型</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jiegiser'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'giser'</span><span class="token punctuation">)</span>
  person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// jiegiser</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新:</span> <span class="time">8/31/2020, 9:10:49 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/Interview/引用类型.html" class="prev">
        引用类型
      </a></span> <span class="next"><a href="/note/Interview/继承.html">
        继承
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/note/assets/js/app.f48e3c9b.js" defer></script><script src="/note/assets/js/2.acebdf5a.js" defer></script><script src="/note/assets/js/17.d0080e19.js" defer></script>
  </body>
</html>
