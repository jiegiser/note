<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>节点层次 | 学习笔记</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="学习笔记">
    <link rel="preload" href="/note/assets/css/0.styles.c9d983ba.css" as="style"><link rel="preload" href="/note/assets/js/app.d0f6c25c.js" as="script"><link rel="preload" href="/note/assets/js/2.0b90f8a6.js" as="script"><link rel="preload" href="/note/assets/js/42.ddb81cd3.js" as="script"><link rel="prefetch" href="/note/assets/js/10.00361fae.js"><link rel="prefetch" href="/note/assets/js/100.5cf1a704.js"><link rel="prefetch" href="/note/assets/js/101.aaf908d6.js"><link rel="prefetch" href="/note/assets/js/102.d1621730.js"><link rel="prefetch" href="/note/assets/js/103.f559b334.js"><link rel="prefetch" href="/note/assets/js/104.0328d8af.js"><link rel="prefetch" href="/note/assets/js/105.1996d24e.js"><link rel="prefetch" href="/note/assets/js/106.2ce6e3f7.js"><link rel="prefetch" href="/note/assets/js/107.5cf3e0ce.js"><link rel="prefetch" href="/note/assets/js/108.d3847fad.js"><link rel="prefetch" href="/note/assets/js/109.5b3506f5.js"><link rel="prefetch" href="/note/assets/js/11.9bacf3e3.js"><link rel="prefetch" href="/note/assets/js/110.9536c51f.js"><link rel="prefetch" href="/note/assets/js/111.96d73132.js"><link rel="prefetch" href="/note/assets/js/112.f73c1644.js"><link rel="prefetch" href="/note/assets/js/113.36ce3455.js"><link rel="prefetch" href="/note/assets/js/114.69dac3b3.js"><link rel="prefetch" href="/note/assets/js/115.81ba1ff7.js"><link rel="prefetch" href="/note/assets/js/116.c4f881ef.js"><link rel="prefetch" href="/note/assets/js/117.c640f24c.js"><link rel="prefetch" href="/note/assets/js/118.e95b274c.js"><link rel="prefetch" href="/note/assets/js/119.7303d633.js"><link rel="prefetch" href="/note/assets/js/12.e2363e6f.js"><link rel="prefetch" href="/note/assets/js/120.2322b287.js"><link rel="prefetch" href="/note/assets/js/121.1602bad2.js"><link rel="prefetch" href="/note/assets/js/122.da6f70c7.js"><link rel="prefetch" href="/note/assets/js/13.77ac299f.js"><link rel="prefetch" href="/note/assets/js/14.9cf15ce7.js"><link rel="prefetch" href="/note/assets/js/15.2eee5c72.js"><link rel="prefetch" href="/note/assets/js/16.618efad0.js"><link rel="prefetch" href="/note/assets/js/17.261823c3.js"><link rel="prefetch" href="/note/assets/js/18.cf01aff4.js"><link rel="prefetch" href="/note/assets/js/19.f1730e8e.js"><link rel="prefetch" href="/note/assets/js/20.7a420af5.js"><link rel="prefetch" href="/note/assets/js/21.5b3d774b.js"><link rel="prefetch" href="/note/assets/js/22.b532e6c6.js"><link rel="prefetch" href="/note/assets/js/23.9dadfc4a.js"><link rel="prefetch" href="/note/assets/js/24.3dfc6f4d.js"><link rel="prefetch" href="/note/assets/js/25.5c06a8b2.js"><link rel="prefetch" href="/note/assets/js/26.274ab673.js"><link rel="prefetch" href="/note/assets/js/27.45d48459.js"><link rel="prefetch" href="/note/assets/js/28.da618cf2.js"><link rel="prefetch" href="/note/assets/js/29.7c6be06a.js"><link rel="prefetch" href="/note/assets/js/3.3fb4e013.js"><link rel="prefetch" href="/note/assets/js/30.bac100b7.js"><link rel="prefetch" href="/note/assets/js/31.4da01b5b.js"><link rel="prefetch" href="/note/assets/js/32.3e930a28.js"><link rel="prefetch" href="/note/assets/js/33.c3751449.js"><link rel="prefetch" href="/note/assets/js/34.d5e4f96a.js"><link rel="prefetch" href="/note/assets/js/35.613e695a.js"><link rel="prefetch" href="/note/assets/js/36.b708ef43.js"><link rel="prefetch" href="/note/assets/js/37.723d6f28.js"><link rel="prefetch" href="/note/assets/js/38.8de7f71d.js"><link rel="prefetch" href="/note/assets/js/39.6ba03778.js"><link rel="prefetch" href="/note/assets/js/4.f8dfd09f.js"><link rel="prefetch" href="/note/assets/js/40.99fc3753.js"><link rel="prefetch" href="/note/assets/js/41.ae901b7a.js"><link rel="prefetch" href="/note/assets/js/43.7676bd03.js"><link rel="prefetch" href="/note/assets/js/44.97d2d99e.js"><link rel="prefetch" href="/note/assets/js/45.3571fd1c.js"><link rel="prefetch" href="/note/assets/js/46.64c49f2b.js"><link rel="prefetch" href="/note/assets/js/47.4af1bc1f.js"><link rel="prefetch" href="/note/assets/js/48.c7a523bf.js"><link rel="prefetch" href="/note/assets/js/49.b6c7ee19.js"><link rel="prefetch" href="/note/assets/js/5.d3f909c4.js"><link rel="prefetch" href="/note/assets/js/50.a3be4789.js"><link rel="prefetch" href="/note/assets/js/51.ec4b5096.js"><link rel="prefetch" href="/note/assets/js/52.5ca649d7.js"><link rel="prefetch" href="/note/assets/js/53.df7f12d6.js"><link rel="prefetch" href="/note/assets/js/54.530445d1.js"><link rel="prefetch" href="/note/assets/js/55.c39f4aa7.js"><link rel="prefetch" href="/note/assets/js/56.121f8e02.js"><link rel="prefetch" href="/note/assets/js/57.82f3e53a.js"><link rel="prefetch" href="/note/assets/js/58.825062e8.js"><link rel="prefetch" href="/note/assets/js/59.87a3ddd2.js"><link rel="prefetch" href="/note/assets/js/6.c69fd30d.js"><link rel="prefetch" href="/note/assets/js/60.88ecad2a.js"><link rel="prefetch" href="/note/assets/js/61.159dab68.js"><link rel="prefetch" href="/note/assets/js/62.02544e05.js"><link rel="prefetch" href="/note/assets/js/63.486d7b6e.js"><link rel="prefetch" href="/note/assets/js/64.18774fd4.js"><link rel="prefetch" href="/note/assets/js/65.3c015540.js"><link rel="prefetch" href="/note/assets/js/66.188262de.js"><link rel="prefetch" href="/note/assets/js/67.4a6b08c8.js"><link rel="prefetch" href="/note/assets/js/68.c13112d5.js"><link rel="prefetch" href="/note/assets/js/69.0fcaedf7.js"><link rel="prefetch" href="/note/assets/js/7.245118db.js"><link rel="prefetch" href="/note/assets/js/70.96d1fa81.js"><link rel="prefetch" href="/note/assets/js/71.555bdbaf.js"><link rel="prefetch" href="/note/assets/js/72.9240651d.js"><link rel="prefetch" href="/note/assets/js/73.3fc5d3eb.js"><link rel="prefetch" href="/note/assets/js/74.c5d0b277.js"><link rel="prefetch" href="/note/assets/js/75.ba7012fb.js"><link rel="prefetch" href="/note/assets/js/76.d7dc6dfc.js"><link rel="prefetch" href="/note/assets/js/77.c825d35c.js"><link rel="prefetch" href="/note/assets/js/78.c1a2a68e.js"><link rel="prefetch" href="/note/assets/js/79.366f636e.js"><link rel="prefetch" href="/note/assets/js/8.d6a925ae.js"><link rel="prefetch" href="/note/assets/js/80.28183475.js"><link rel="prefetch" href="/note/assets/js/81.f09b21e9.js"><link rel="prefetch" href="/note/assets/js/82.cec989c4.js"><link rel="prefetch" href="/note/assets/js/83.a02dfe8e.js"><link rel="prefetch" href="/note/assets/js/84.6a7ab9f2.js"><link rel="prefetch" href="/note/assets/js/85.df4623b9.js"><link rel="prefetch" href="/note/assets/js/86.2eb26d7f.js"><link rel="prefetch" href="/note/assets/js/87.12185ba7.js"><link rel="prefetch" href="/note/assets/js/88.cf65df05.js"><link rel="prefetch" href="/note/assets/js/89.0e58eb08.js"><link rel="prefetch" href="/note/assets/js/9.60d51fbf.js"><link rel="prefetch" href="/note/assets/js/90.503f8ea4.js"><link rel="prefetch" href="/note/assets/js/91.42e5be12.js"><link rel="prefetch" href="/note/assets/js/92.0be6602f.js"><link rel="prefetch" href="/note/assets/js/93.dc6b8bf6.js"><link rel="prefetch" href="/note/assets/js/94.c58d28eb.js"><link rel="prefetch" href="/note/assets/js/95.251d907b.js"><link rel="prefetch" href="/note/assets/js/96.062afb22.js"><link rel="prefetch" href="/note/assets/js/97.da27c972.js"><link rel="prefetch" href="/note/assets/js/98.d8ca8912.js"><link rel="prefetch" href="/note/assets/js/99.6391eb22.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.c9d983ba.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/note/css/css基础.html" class="nav-link">
  css 相关
</a></div><div class="nav-item"><a href="/note/react/react基础.html" class="nav-link">
  react 相关
</a></div><div class="nav-item"><a href="/note/js-patterns/代理模式.html" class="nav-link">
  js 设计模式
</a></div><div class="nav-item"><a href="/note/typescript/typescript基础语法.html" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/note/node/基础知识.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/note/javascript/知识体系.html" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/note/vue/相关笔记.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/note/webpack/基础知识.html" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/note/webgis/坐标系相关.html" class="nav-link">
  webgis
</a></div><div class="nav-item"><a href="/note/http/HTTP协议基础.html" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="nav-link">
  Interview
</a></div><div class="nav-item"><a href="/note/gisAlgorithm/数据结构-矢量.html" class="nav-link">
  gis 算法
</a></div><div class="nav-item"><a href="/note/graphics/图形学基础.html" class="nav-link">
  图形学相关
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/note/css/css基础.html" class="nav-link">
  css 相关
</a></div><div class="nav-item"><a href="/note/react/react基础.html" class="nav-link">
  react 相关
</a></div><div class="nav-item"><a href="/note/js-patterns/代理模式.html" class="nav-link">
  js 设计模式
</a></div><div class="nav-item"><a href="/note/typescript/typescript基础语法.html" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/note/node/基础知识.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/note/javascript/知识体系.html" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/note/vue/相关笔记.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/note/webpack/基础知识.html" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/note/webgis/坐标系相关.html" class="nav-link">
  webgis
</a></div><div class="nav-item"><a href="/note/http/HTTP协议基础.html" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="nav-link">
  Interview
</a></div><div class="nav-item"><a href="/note/gisAlgorithm/数据结构-矢量.html" class="nav-link">
  gis 算法
</a></div><div class="nav-item"><a href="/note/graphics/图形学基础.html" class="nav-link">
  图形学相关
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="sidebar-link">forEach、for in、for of、map之间的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#foreach" class="sidebar-link">1️⃣ forEach</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#语法" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#参数" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#使用" class="sidebar-link">使用</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#不同点" class="sidebar-link">不同点</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#for-in" class="sidebar-link">2️⃣ for...in</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#语法-2" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#示例" class="sidebar-link">示例</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#遍历数组的缺点" class="sidebar-link">遍历数组的缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#for-of" class="sidebar-link">3️⃣ for...of</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#语法-3" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#示例-2" class="sidebar-link">示例</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#跳出循环" class="sidebar-link">跳出循环</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#与-for-in-的区别" class="sidebar-link">与 for...in 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#map" class="sidebar-link">4️⃣ map</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#语法-4" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#参数-2" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#返回值" class="sidebar-link">返回值</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#补充说明" class="sidebar-link">✏️ 补充说明</a></li></ul></li><li><a href="/note/Interview/数据类型.html" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/数据类型.html#数据类型" class="sidebar-link">💫 数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/数据类型.html#number" class="sidebar-link">👉 Number</a></li><li class="sidebar-sub-header"><a href="/note/Interview/数据类型.html#string" class="sidebar-link">👉 String</a></li><li class="sidebar-sub-header"><a href="/note/Interview/数据类型.html#object" class="sidebar-link">👉 Object</a></li></ul></li></ul></li><li><a href="/note/Interview/操作符.html" class="sidebar-link">操作符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#操作符" class="sidebar-link">操作符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#一元操作符" class="sidebar-link">一元操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#布尔操作符" class="sidebar-link">布尔操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#逻辑或" class="sidebar-link">逻辑或</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#乘法操作符" class="sidebar-link">乘法操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#除法操作符" class="sidebar-link">除法操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#求模" class="sidebar-link">求模</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#加性操作符" class="sidebar-link">加性操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#关系操作符" class="sidebar-link">关系操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#相等操作符" class="sidebar-link">相等操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#逗号操作符" class="sidebar-link">逗号操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#breack-和-continue-语句" class="sidebar-link">breack 和 continue 语句</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#switch-语句" class="sidebar-link">switch 语句</a></li></ul></li></ul></li><li><a href="/note/Interview/变量、作用域和内存.html" class="sidebar-link">变量、作用域和内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#变量、作用域和内存问题" class="sidebar-link">变量、作用域和内存问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#检测类型" class="sidebar-link">检测类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#执行环境以及作用域" class="sidebar-link">执行环境以及作用域</a></li><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#垃圾收集" class="sidebar-link">垃圾收集</a></li><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#javascript-v8-引擎的垃圾回收机制" class="sidebar-link">JavaScript V8 引擎的垃圾回收机制</a></li></ul></li></ul></li><li><a href="/note/Interview/引用类型.html" class="sidebar-link">引用类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#object-类型" class="sidebar-link">Object 类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#array-类型" class="sidebar-link">Array 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#date-类型" class="sidebar-link">Date 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#regexp-类型" class="sidebar-link">RegExp 类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#函数声明与函数表达式" class="sidebar-link">函数声明与函数表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#函数的内部属性" class="sidebar-link">函数的内部属性</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#函数属性和方法" class="sidebar-link">函数属性和方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#基本包装类型" class="sidebar-link">基本包装类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#boolean-对象" class="sidebar-link">Boolean 对象</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#number-类型" class="sidebar-link">Number 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#string-类型" class="sidebar-link">String 类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#单体内置对象" class="sidebar-link">单体内置对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#global-对象" class="sidebar-link">Global 对象</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#math-对象" class="sidebar-link">Math 对象</a></li></ul></li></ul></li><li><a href="/note/Interview/对象的创建模式.html" class="sidebar-link">对象的创建模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#理解对象" class="sidebar-link">理解对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#属性类型" class="sidebar-link">属性类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#创建对象" class="sidebar-link">创建对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#工厂模式" class="sidebar-link">工厂模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#构造函数模式" class="sidebar-link">构造函数模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#原型模式" class="sidebar-link">原型模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#组合使用构造函数模式和原型模式（最常用的模式）" class="sidebar-link">组合使用构造函数模式和原型模式（最常用的模式）</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#动态原型模式" class="sidebar-link">动态原型模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#寄生构造函数模式" class="sidebar-link">寄生构造函数模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#稳妥构造函数模式" class="sidebar-link">稳妥构造函数模式</a></li></ul></li></ul></li><li><a href="/note/Interview/继承.html" class="sidebar-link">继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#原型链" class="sidebar-link">原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#默认的原型" class="sidebar-link">默认的原型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#确定原型和实例之间的关系" class="sidebar-link">确定原型和实例之间的关系</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#谨慎地定义方法" class="sidebar-link">谨慎地定义方法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#原型链的问题" class="sidebar-link">原型链的问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#借用构造函数" class="sidebar-link">借用构造函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#传递参数" class="sidebar-link">传递参数</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#借用构造函数存在的问题" class="sidebar-link">借用构造函数存在的问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#组合继承（最常用）" class="sidebar-link">组合继承（最常用）</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#原型式继承" class="sidebar-link">原型式继承</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#寄生式继承" class="sidebar-link">寄生式继承</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#寄生组合式继承" class="sidebar-link">寄生组合式继承</a></li></ul></li><li><a href="/note/Interview/函数表达式.html" class="sidebar-link">函数表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#函数定义" class="sidebar-link">函数定义</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#函数声明" class="sidebar-link">函数声明</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#函数表达式" class="sidebar-link">函数表达式</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#创建闭包" class="sidebar-link">创建闭包</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#闭包与变量" class="sidebar-link">闭包与变量</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#关于-this-对象" class="sidebar-link">关于 this 对象</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#内存泄漏" class="sidebar-link">内存泄漏</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#模仿块级作用域" class="sidebar-link">模仿块级作用域</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#私有变量" class="sidebar-link">私有变量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#静态私有变量" class="sidebar-link">静态私有变量</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#模块模式" class="sidebar-link">模块模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#增强的模块模式" class="sidebar-link">增强的模块模式</a></li></ul></li></ul></li><li><a href="/note/Interview/BOM.html" class="sidebar-link">BOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#window-对象" class="sidebar-link">window 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#全局作用域" class="sidebar-link">全局作用域</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#窗口关系及框架" class="sidebar-link">窗口关系及框架</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#窗口位置" class="sidebar-link">窗口位置</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#窗口大小" class="sidebar-link">窗口大小</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#导航和打开窗口" class="sidebar-link">导航和打开窗口</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#settimeout-setinterval" class="sidebar-link">setTimeout/setInterval</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#系统对话框" class="sidebar-link">系统对话框</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#location-对象" class="sidebar-link">location 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#查询字符串参数" class="sidebar-link">查询字符串参数</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#位置操作" class="sidebar-link">位置操作</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#nagigator-对象" class="sidebar-link">nagigator 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#检查插件" class="sidebar-link">检查插件</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#history-对象" class="sidebar-link">history 对象</a></li></ul></li><li><a href="/note/Interview/DOM.html" aria-current="page" class="active sidebar-link">DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#节点层次" class="sidebar-link">节点层次</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#node-类型" class="sidebar-link">Node 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#document-类型" class="sidebar-link">Document 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#element-类型" class="sidebar-link">Element 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#text-类型" class="sidebar-link">Text 类型</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="节点层次"><a href="#节点层次" class="header-anchor">#</a> 节点层次</h2> <p>HTML 中每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点来表示，而注释通过注释节点来表示。</p> <h3 id="node-类型"><a href="#node-类型" class="header-anchor">#</a> Node 类型</h3> <p>JavaScript 中所有节点类型都继承自 Node 类型，因此所有节点属性都共享着相同的基本属性和方法。</p> <p>每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列 12 个数值常量来表示，任何节点类型必具其一：</p> <ul><li>Node.ELEMENT_NODE(1)</li> <li>Node.ATTRIBUTE_NODE(2)</li> <li>Node.TEXT_NODE(3)</li> <li>Node.CDATA_SECTION_NODE(4)</li> <li>Node.ENTITY_PREPERENCE_NODE(5)</li> <li>Node.ENTITY_NODE(6)</li> <li>Node.PROCESSING_INSTRUCTION_NODE(7)</li> <li>Node.COMMENT_NODE(8)</li> <li>Node.DOCUMENT_NODE(9)</li> <li>Node.DOCUMENT_TYPE_NODE(10)</li> <li>Node.DOCUMENT_FRAGMENT_NODE(11)</li> <li>Node.NOTATION_NODE(12)</li></ul> <p>通过比较上面这些常量，可以很容易地确定节点的类型，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在 IE 中无效</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>someNode<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> Node<span class="token punctuation">.</span><span class="token constant">ELEMENT_NODE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'node is an element'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 可以通过与数值进行比较适用于所有浏览器</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>someNode<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'node is an element'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="nodename-和-nodevalue-属性"><a href="#nodename-和-nodevalue-属性" class="header-anchor">#</a> nodeName 和 nodeValue 属性</h4> <p>nodeName 是元素的标签名。Node 的 nodeValue 属性返回或设置当前节点的值。</p> <h4 id="节点关系"><a href="#节点关系" class="header-anchor">#</a> 节点关系</h4> <ul><li>每个节点都有一个 childNodes 属性，用于保存他的子元素，是一个 NodeList 对象，NodeList 是一种 类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。NodeList 实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反应在 NodeList 对象中。他并不是在某一时期的快照。</li></ul> <p>下面代码将 NodeList 对象转换为数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在 IE8 之前无效</span>
<span class="token keyword">var</span> arrayOfNodes <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>someNode<span class="token punctuation">,</span> chilNodes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><p>下面代码是兼容 IE8：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">convertToArray</span><span class="token punctuation">(</span><span class="token parameter">nodes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    array <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> leng <span class="token operator">=</span> nodes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>每个节点都有一个 parentNode 属性；该属性指向文档树中的父节点。包含在 childrenNodes 列表中的每个节点相互之间都是同胞节点，通过使用列表中每个节点的 previousSibling 和 nextSilling 属性，可以访问他的前一个与后一个兄弟节点。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>someNodes<span class="token punctuation">.</span>nextSibling <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Last node in the parents childNodes list'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>someNodes<span class="token punctuation">.</span>previousSibling <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'First node in the parents childNodes list'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和最后一个节点。</p></li> <li><p>使用 hasChildNodes() 方法可以检查是否有子节点；</p></li> <li><p>所有节点都有一个最后一个属性是 ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于他所在的文档，任何节点都不能同时存在于两个或更多的文档中。通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档顶点。</p></li></ul> <h4 id="操作节点"><a href="#操作节点" class="header-anchor">#</a> 操作节点</h4> <ul><li>appendChild() 方法：用于向 chilNodes 列表的末尾添加一个节点。返回值为新增的节点。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> returnedNode <span class="token operator">=</span> someNode<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnedNode <span class="token operator">===</span> newNode<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>someNode<span class="token punctuation">.</span>lastChild <span class="token operator">===</span> newNode<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>如果新添加的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新文职。即使可以将 DOM 树看成是由一系列指针连接起来的，但任何 DOM 节点也不能同时出现在文档中的多个位置上。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// someNode 有多个子节点</span>
<span class="token keyword">var</span> returnedNode <span class="token operator">=</span> someNode<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>someNode<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnNode <span class="token operator">===</span> someNode<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnNode <span class="token operator">===</span> someNode<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><ul><li>insertBefore() 方法：用于将节点放在 childNodes 列表中某个特定的位置上；他接收两个参数，第一个是要插入节点，第二个是作为参照的节点；插入节点后，被插入的节点会变成参照节点的前一个兄弟节点，同时被方法返回。如果参照节点是 null，则 insertBefore() 与 appendChild() 执行相同的操作，如下</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 插入后成为左右一个子节点</span>
returnNode <span class="token operator">=</span> someNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newNode <span class="token operator">===</span> someNode<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// 插入后成为第一个子节点</span>
returnNode <span class="token operator">=</span> someNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> someNode<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnNode <span class="token operator">===</span> newNode<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newNode <span class="token operator">===</span> someNode<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// 插入到最后一个子节点的前面</span>
returnNode <span class="token operator">=</span> someNoed<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> someNode<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newNode <span class="token operator">===</span> someNode<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span>someNode<span class="token punctuation">.</span>childNodes<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><ul><li>replaceChild() 方法：替换节点。接收两个参数，要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点替换其位置，如下：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 替换第一个子节点</span>
<span class="token keyword">var</span> returnedNode <span class="token operator">=</span> someNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> someNode<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span>

<span class="token comment">// 替换最后一个子节点</span>
<span class="token keyword">var</span> rerurnedNode <span class="token operator">=</span> someNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> someNode<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span>
</code></pre></div><ul><li>removeChild() 方法：移除节点，该方法接收一个参数，即要移除的节点，该方法的返回值为被移除的节点。如下：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 移除第一个子节点</span>
<span class="token keyword">var</span> formerFirstChild <span class="token operator">=</span> someNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>someNode<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span>

<span class="token comment">// 移除最后一个子节点</span>
<span class="token keyword">var</span> formerLastChild <span class="token operator">=</span> someNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>someNode<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span>
</code></pre></div><h4 id="其他方法"><a href="#其他方法" class="header-anchor">#</a> 其他方法</h4> <ul><li><p>cloneNode() 方法：用于创建调用这个方法的节点的一个完全相同的副本；接收一个布尔值参数，表示是否执行深拷贝，ture 执行深拷贝。也就是复制节点及其整个子节点树；参数为 false 的情况下，执行浅拷贝，即只拷贝节点本身。拷贝的节点需要指定父节点，可以通过 appendChild()、insertBefore() 或者 replaceChild() 将它添加到文档中。</p></li> <li><p>normalize() 方法：主要作用处理文档树中的文本节点。由于解析器的实现或 DOM 操作的原因，可能出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除他，如果找到相邻的文本节点 ，则将他们合并为一个文本节点。</p></li></ul> <h3 id="document-类型"><a href="#document-类型" class="header-anchor">#</a> Document 类型</h3> <p>JavaScript 通过 Document 类型表示文档，在浏览器中，document 对象是 HTMLDocument （继承自 Document 类型） 的一个实例，表示整个 HTML 页面。而且 document 对象是 window 对象的一个属性。具有以下特性：</p> <ul><li>nodeType 为 9</li> <li>nodeName 的值为 '#document'</li> <li>nodeValue 的值为 null</li> <li>parentNode 的值为 null</li> <li>ownerDocument 的值为 null</li> <li>其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。</li></ul> <h4 id="文档的子节点"><a href="#文档的子节点" class="header-anchor">#</a> 文档的子节点</h4> <ul><li>可以通过 documentElement 属性，访问 HTML 页面中的 HTML 元素。</li> <li>可以通过 childNodes 列表访问文档元素。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> html <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement <span class="token comment">// 取得 html 的引用</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html <span class="token operator">===</span> document<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html <span class="token operator">===</span> document<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><blockquote><p>所有浏览器都支持 document.documentElement 和 document.body 属性；</p></blockquote> <ul><li>可以通过 document.doctype 获取 DOCTYPE 标签的引用。</li></ul> <h4 id="文档信息"><a href="#文档信息" class="header-anchor">#</a> 文档信息</h4> <ul><li>document.title 属性：包含着 title 标签元素中的文本。</li> <li>document.URL 属性：包含页面完整的 URL。</li> <li>document.domain 属性：只包含页面的域名。</li> <li>document.referrer 属性：保存着链接当前页面的那个页面的 URL。在没有来源页面的情况下，该 属性中可能会包含空字符串。</li></ul> <p>上面的属性中，只有 domain 属性可以设置，但由于安全方面的限制，也并非可以给 domain 设置任何值。如果 URL 中包含一个子域名，例如 P2.wrox.com，那么只能将 domain设置为 wrox.com （URL 中包含 www，如 www.wrox.com 时，也是如此），不能将这个属性设置为 URL 中不包含的域。如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 假设页面来自于 p2p.wrox.com</span>
document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'wrox.com'</span> <span class="token comment">// 成功</span>
document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'nczonline.net'</span> <span class="token comment">// 失败</span>
</code></pre></div><h4 id="查找元素"><a href="#查找元素" class="header-anchor">#</a> 查找元素</h4> <ul><li>getElementById()：接收一个参数，要取得的元素的 id，如果找到相应的元素则返回该元素，如果不存在带有相应 id 的元素，则返回 null。如果页面中有多个元素的 id 值是相同的，那么只返回文档中第一次出现的元素。</li> <li>getElementsByTagName()：接收一个参数，即要取得元素的标签名，而返回的是包含零或者多个元素的 NodeList。在 HTML 文档中，这个方法返回一个 HTMLCollection 对象。该对象有一个 namedItem() 方法，使用这个方法可以通过元素的 name 特性取得集合中的项。在提供按索引访问项的基础上，HTMLCollection 还支持按名称访问项，对命名的项可以使用方括号语法来访问（就是传入元素的 name 属性），如果要取得所有元素，则传入 &quot;*&quot; ，获取全部元素。</li> <li>getElementsByName()：这个方法会返回带有给定 name 特性的所有元素。一般用于获取单选按钮。为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的 name 特性；这个方法返回一个 HTMLCollection 对象。</li></ul> <h4 id="特殊集合"><a href="#特殊集合" class="header-anchor">#</a> 特殊集合</h4> <ul><li>document.anchors：包含文档中所有带 name 特性的 a 元素；</li> <li>document.applets：包含文档中所有的 applet 元素；</li> <li>document.forms：包含文档中所有的 form 元素，与 document.getElementsByTagName('form') 得到的结果一致；</li> <li>document.images：包含文档中所有的 img 元素，与 document.getElementsByTagName('img') 得到的结果一致；</li> <li>document.links：包含文档中所有带 href 特性的 a 元素；</li></ul> <h4 id="文档写入"><a href="#文档写入" class="header-anchor">#</a> 文档写入</h4> <p>将输出流写入到网页中主要为下面几个方法：这几个方法都接收一个字符串参数，即要写入到输出流中的文本；</p> <ul><li>write()：原样写入</li> <li>writeln()：会在每个字符串的末尾添加一个换行符
在页面被加载的过程中，可以使用上面两个方法向页面中动态地加入内容。</li> <li>open()：打开网页的输出流。</li> <li>close()：关闭网页的输出流。
如果是在页面加载期间使用 write() 或 writeln() 方法，则不需要使用上面两个方法。</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>document.write() example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>The current date and time is:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
      document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'&lt;strong&gt;'</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'&lt;/strong&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面的代码使用功能 document.write() 在页面被呈现的过程中直接向其中输出了内容，如果在文档加载结束后再调用 document.write() ，那么输出的内容将会重写整个页面。</p> <h3 id="element-类型"><a href="#element-类型" class="header-anchor">#</a> Element 类型</h3> <p>Element 类型提供了对元素标签名、子节点及特性的访问，具有下面特性：</p> <ul><li>nodeType 的值为 1</li> <li>nodeName 的值为元素的标签名</li> <li>nodeValue 的值为 null</li> <li>parentNode 可能是 Document 或 Element</li> <li>其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference</li></ul> <p>如果要访问元素的标签名，可以使用 nodeName 或者 tagName 属性；在 HTML 中标签名始终都已全部大写表示。我们如果需要比较可以将其转换为小写进行比较：element.tagName.toLowerCase()。</p> <h4 id="html-元素"><a href="#html-元素" class="header-anchor">#</a> HTML 元素</h4> <p>HTML 元素都由 HTMLELement 类型表示，不是直接通过这个类型，也是通过他的自列席来表示，HTMLElement 类型直接继承自 Element 并添加了一些属性。添加的这些属性分别对应每个 HTML 元素中都存在的下列标准属性：</p> <ul><li>id</li> <li>title</li> <li>lang</li> <li>dir：语言的方向</li> <li>className</li></ul> <p>上面这些属性都可以通过读取属性方式获取：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myDiv'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>title<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>className<span class="token punctuation">)</span>
<span class="token comment">// 也可以直接进行赋值，修改对应的属性</span>
div<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'someo'</span>
div<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'ft'</span>
</code></pre></div><h4 id="获取属性"><a href="#获取属性" class="header-anchor">#</a> 获取属性</h4> <p>操作属性主要有三个方法：getAttribute()、setAttribute() 和 removeAttribute() ;</p> <ul><li>传递给 getAttribute() 的特性名需要与实际的特性名一致，如 class 应该传入 class；也可以访问到自己定义的特性。自定义的特性应该加上 data- 前缀以便验证。</li></ul> <p>任何元素的所有特性，也都可以通过 DOM 元素本身的属性来访问，不过只有公认的（非自定义）特性才会以属性的形式添加到 DOM 对象中，如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>myDiv<span class="token punctuation">&quot;</span></span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>left<span class="token punctuation">&quot;</span></span> <span class="token attr-name">my_attribute</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>hello<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>因为 id 和 align 在 HTML 中是 div 的公认特性，因此该元素的 DOM 对象中也将存在对应的属性，不过自定义的属性在除 IE 浏览器外是不存在的：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token comment">// myDiv</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>my_attribute<span class="token punctuation">)</span> <span class="token comment">// undefined(IE 除外)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>align<span class="token punctuation">)</span> <span class="token comment">// left</span>
</code></pre></div><p>有两种比较特殊的属性，属性值与 getAttribute() 返回的值并不相同：</p> <ul><li>style 属性：使用 getAttribute() 返回的 style 属性中包含的是 css 文本，通过属性访问则返回的是一个对象。</li> <li>onclick 这种事件处理程序：getAttribute() 返回的是相应的代码字符串，通过属性访问返回是一个 JavaScript 函数。</li></ul> <h4 id="设置属性"><a href="#设置属性" class="header-anchor">#</a> 设置属性</h4> <p>setAttribute()：接收两个参数，要设置的属性名，以及值。如果要设置的属性已经存在，那么就会替换现有的值。通过这个方法设置的属性名会被统一转换为小写的形式。
也可以直接通过属性值进行设置：div.id = 'some' 这样设置也可以，不过自定义的属性是不能通过这种方式设置。</p> <p>removeAttribute() ：用于彻底删除元素的特性，调用这个方法不仅会清除属性的值，而且会直接删除属性。</p> <h4 id="attributes-属性"><a href="#attributes-属性" class="header-anchor">#</a> attributes 属性</h4> <p>attributes 属性中包含一个 NamedNodeMap，与 NodeList 类似，也是一个动态的集合，元素的每一个属性都由一个 Attr 节点表示，每个节点都保存在 NamedNodeMap 对象中， NamedNodeMap 对象拥有下面方法：</p> <ul><li>getNamedItem(name)：返回 nodeName 属性等于 name 的节点</li> <li>removeNamedItem(name)：从列表中移除 nodeName 等于 那么的节点</li> <li>setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引</li> <li>item(pos)：返回位于数字 pos 位置处的节点</li></ul> <p>attributes 属性中包含一系列节点，每个节点的 nodeName 就是特性的名称，而节点的 nodeValue 就是特性的值，要取得 id 的属性，入下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> id <span class="token operator">=</span> element<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span><span class="token function">getNamedItem</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>nodeValue
<span class="token comment">// 也可以用下面代码</span>
<span class="token keyword">var</span> id <span class="token operator">=</span> element<span class="token punctuation">.</span>attributesp<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>nodeValue
</code></pre></div><p>也可以使用这种语法来设置属性的值：</p> <div class="language-js extra-class"><pre class="language-js"><code>element<span class="token punctuation">.</span>attributes<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> <span class="token string">'someother'</span>
</code></pre></div><p>调用 removeNamedItem() 方法与在元素上调用 removeAttribute() 方法的效果相同。两个方法的唯一区别是 removeNamedItem() 方法返回表示被删除属性的 Attr 节点;</p> <p>setNamedItem() 可以为元素添加一个新属性：</p> <div class="language-js extra-class"><pre class="language-js"><code>element<span class="token punctuation">.</span>attribute<span class="token punctuation">.</span><span class="token function">setNamedItem</span><span class="token punctuation">(</span>newAttr<span class="token punctuation">)</span>
</code></pre></div><p>下面代码是遍历元素的属性，构造成 name = 'value' name = 'value' 这样的字符串格式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outputAttributes</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> pairs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> len <span class="token operator">=</span> element<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> attribute <span class="token operator">=</span> element<span class="token punctuation">.</span>attributes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    pairs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>attribute<span class="token punctuation">.</span>nodeName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>attribute<span class="token punctuation">.</span>nodeValue<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> pairs<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="创建元素"><a href="#创建元素" class="header-anchor">#</a> 创建元素</h4> <ul><li>document.createElement() 方法创建新元素，该方法接收一个参数，即要创建元素的标签名。使用 createElement() 方法创建新元素的同时也会将其 ownerDocument 属性设置为 document ，此时，可以再为其添加属性、添加更多子元素。比如：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>div<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">&quot;myNewDiv&quot;</span>
div<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">&quot;box&quot;</span>
</code></pre></div><p>可以使用 appendChild() 、 insertBefore() 或 replaceChild() 。</p> <h4 id="后代的子节点"><a href="#后代的子节点" class="header-anchor">#</a> 后代的子节点</h4> <p>元素的 childNodes 包含所有子节点，这些子节点可能是其他元素、文本节点、注释或处理指令；可以通过下面代码筛选元素节点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> len <span class="token operator">=</span> element<span class="token punctuation">.</span>childNodes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行某些操作</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果需要通过特定的标签名取得子元素或后代节点，可以使用元素的 getElementsByTagName() 方法，他会限制搜索范围只在当前元素内，也就是说只返回当前元素后代中特定的元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myList'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> items <span class="token operator">=</span> ul<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="text-类型"><a href="#text-类型" class="header-anchor">#</a> Text 类型</h3> <p>文本节点由 Text 类型表示，包含按字面解释的纯文本内容，纯文本中可以包含转以后的 HTML 字符，但不能包含 HTML 代码，Text 类型具有以下特性：</p> <ul><li>nodeType 等于 3；</li> <li>nodeName 值为 &quot;#text&quot; ；</li> <li>nodeValue 值为节点中包含的文本；</li> <li>parentNode 值为 Element 对象；</li> <li>不支持子节点</li></ul> <p>可以通过 nodeValue 属性或者 data 属性访问 Text 节点中包含的文本，这两个属性中包含的值是相同的，对 nodeValue 的修改也会通过 data 反映出来，可以使用下列方法操作节点中的文本：</p> <ul><li>appendData(text)：向节点末尾添加文本 text；</li> <li>deleteData(offset, count)：从位置 offset 开始删除 count 个字符；</li> <li>insertData(offset, text)：在位置 offset 插入 text；</li> <li>replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset + count 为止处的文本；</li> <li>splitText(offset)：从 offset 指定的位置将当前文本节点分为两个文本节点；</li> <li>substringData(offset, count)：提取从位置 offset 到 offset + count 位置的字符串；</li></ul> <p>如下代码：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>可以通过下面代码访问文本节点</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> textNode <span class="token operator">=</span> div<span class="token punctuation">.</span>firsrChild <span class="token comment">// 或 div.childNodes[0]</span>
<span class="token comment">// 修改</span>
div<span class="token punctuation">.</span>firstChild<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> <span class="token string">'some other message'</span>
</code></pre></div><p>修改文本的时候还需要注意就是 HTML 或 XML 代码会被转换为实体编码，即小于号、大于号或引号会被转义，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot;</span>
div<span class="token punctuation">.</span>firstChild<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> <span class="token string">&quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;</span>
</code></pre></div><h4 id="创建文本节点"><a href="#创建文本节点" class="header-anchor">#</a> 创建文本节点</h4> <p>使用 document.createTextNode() 创建新文本节点；它接收一个参数，即要插入节点的文本。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新:</span> <span class="time">9/29/2020, 9:14:00 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/Interview/BOM.html" class="prev">
        BOM
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/note/assets/js/app.d0f6c25c.js" defer></script><script src="/note/assets/js/2.0b90f8a6.js" defer></script><script src="/note/assets/js/42.ddb81cd3.js" defer></script>
  </body>
</html>
