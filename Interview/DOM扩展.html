<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>选择符 API | 学习笔记</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="学习笔记">
    <link rel="preload" href="/note/assets/css/0.styles.c9d983ba.css" as="style"><link rel="preload" href="/note/assets/js/app.7916f9d6.js" as="script"><link rel="preload" href="/note/assets/js/2.4766c975.js" as="script"><link rel="preload" href="/note/assets/js/47.f18b0fed.js" as="script"><link rel="prefetch" href="/note/assets/js/10.505044cf.js"><link rel="prefetch" href="/note/assets/js/100.48b09150.js"><link rel="prefetch" href="/note/assets/js/101.e313c23c.js"><link rel="prefetch" href="/note/assets/js/102.6b6d1b38.js"><link rel="prefetch" href="/note/assets/js/103.4a5c72cb.js"><link rel="prefetch" href="/note/assets/js/104.abe6c347.js"><link rel="prefetch" href="/note/assets/js/105.269bac5c.js"><link rel="prefetch" href="/note/assets/js/106.4230c2a3.js"><link rel="prefetch" href="/note/assets/js/107.395df111.js"><link rel="prefetch" href="/note/assets/js/108.0d8e8b5d.js"><link rel="prefetch" href="/note/assets/js/109.e0c3dec6.js"><link rel="prefetch" href="/note/assets/js/11.69283d2d.js"><link rel="prefetch" href="/note/assets/js/110.e001ad75.js"><link rel="prefetch" href="/note/assets/js/111.7ede74cd.js"><link rel="prefetch" href="/note/assets/js/112.d7ef27ba.js"><link rel="prefetch" href="/note/assets/js/113.b80a0787.js"><link rel="prefetch" href="/note/assets/js/114.cb553bb7.js"><link rel="prefetch" href="/note/assets/js/115.2e748f67.js"><link rel="prefetch" href="/note/assets/js/116.d5ae7c93.js"><link rel="prefetch" href="/note/assets/js/117.379f058a.js"><link rel="prefetch" href="/note/assets/js/118.ebe56138.js"><link rel="prefetch" href="/note/assets/js/119.c85a361d.js"><link rel="prefetch" href="/note/assets/js/12.70f40b17.js"><link rel="prefetch" href="/note/assets/js/120.bc19049c.js"><link rel="prefetch" href="/note/assets/js/121.a013ce97.js"><link rel="prefetch" href="/note/assets/js/122.50725d3e.js"><link rel="prefetch" href="/note/assets/js/123.de4086d2.js"><link rel="prefetch" href="/note/assets/js/124.30813932.js"><link rel="prefetch" href="/note/assets/js/125.650afc28.js"><link rel="prefetch" href="/note/assets/js/126.47a63737.js"><link rel="prefetch" href="/note/assets/js/13.c5bf48cf.js"><link rel="prefetch" href="/note/assets/js/14.5d746e1a.js"><link rel="prefetch" href="/note/assets/js/15.d288f5d6.js"><link rel="prefetch" href="/note/assets/js/16.9ec6433e.js"><link rel="prefetch" href="/note/assets/js/17.c028b26e.js"><link rel="prefetch" href="/note/assets/js/18.705894ef.js"><link rel="prefetch" href="/note/assets/js/19.00a48a2e.js"><link rel="prefetch" href="/note/assets/js/20.50dc62f6.js"><link rel="prefetch" href="/note/assets/js/21.939f7854.js"><link rel="prefetch" href="/note/assets/js/22.eaf38316.js"><link rel="prefetch" href="/note/assets/js/23.38d1fab3.js"><link rel="prefetch" href="/note/assets/js/24.bd7fae2f.js"><link rel="prefetch" href="/note/assets/js/25.413b8bc1.js"><link rel="prefetch" href="/note/assets/js/26.32309c5e.js"><link rel="prefetch" href="/note/assets/js/27.404cde38.js"><link rel="prefetch" href="/note/assets/js/28.399a10a9.js"><link rel="prefetch" href="/note/assets/js/29.514c169a.js"><link rel="prefetch" href="/note/assets/js/3.70acb567.js"><link rel="prefetch" href="/note/assets/js/30.f8c50604.js"><link rel="prefetch" href="/note/assets/js/31.93b1ca13.js"><link rel="prefetch" href="/note/assets/js/32.4c9b409c.js"><link rel="prefetch" href="/note/assets/js/33.62308ec1.js"><link rel="prefetch" href="/note/assets/js/34.4dfb53c7.js"><link rel="prefetch" href="/note/assets/js/35.9141ffe4.js"><link rel="prefetch" href="/note/assets/js/36.bda66d22.js"><link rel="prefetch" href="/note/assets/js/37.eeff41ec.js"><link rel="prefetch" href="/note/assets/js/38.d6705e64.js"><link rel="prefetch" href="/note/assets/js/39.6e29c301.js"><link rel="prefetch" href="/note/assets/js/4.fdd19fe8.js"><link rel="prefetch" href="/note/assets/js/40.635f314e.js"><link rel="prefetch" href="/note/assets/js/41.77695720.js"><link rel="prefetch" href="/note/assets/js/42.e338fa0a.js"><link rel="prefetch" href="/note/assets/js/43.c1dca12c.js"><link rel="prefetch" href="/note/assets/js/44.ab263910.js"><link rel="prefetch" href="/note/assets/js/45.7ec4294e.js"><link rel="prefetch" href="/note/assets/js/46.b2282ca4.js"><link rel="prefetch" href="/note/assets/js/48.9a662e9b.js"><link rel="prefetch" href="/note/assets/js/49.29139671.js"><link rel="prefetch" href="/note/assets/js/5.43a235ed.js"><link rel="prefetch" href="/note/assets/js/50.fb1a5a01.js"><link rel="prefetch" href="/note/assets/js/51.9c15fc4c.js"><link rel="prefetch" href="/note/assets/js/52.7fb54b83.js"><link rel="prefetch" href="/note/assets/js/53.18e86a5e.js"><link rel="prefetch" href="/note/assets/js/54.4e5fb52d.js"><link rel="prefetch" href="/note/assets/js/55.f526f60a.js"><link rel="prefetch" href="/note/assets/js/56.e3d7d279.js"><link rel="prefetch" href="/note/assets/js/57.73d54a9b.js"><link rel="prefetch" href="/note/assets/js/58.8977cdc9.js"><link rel="prefetch" href="/note/assets/js/59.ca27782e.js"><link rel="prefetch" href="/note/assets/js/6.6d6fdb88.js"><link rel="prefetch" href="/note/assets/js/60.ff74fef2.js"><link rel="prefetch" href="/note/assets/js/61.88ccfa4b.js"><link rel="prefetch" href="/note/assets/js/62.f14d955c.js"><link rel="prefetch" href="/note/assets/js/63.0a8d241f.js"><link rel="prefetch" href="/note/assets/js/64.7b4581f6.js"><link rel="prefetch" href="/note/assets/js/65.a383f592.js"><link rel="prefetch" href="/note/assets/js/66.04d4a9b8.js"><link rel="prefetch" href="/note/assets/js/67.0b67054e.js"><link rel="prefetch" href="/note/assets/js/68.55addeac.js"><link rel="prefetch" href="/note/assets/js/69.9cf7efc7.js"><link rel="prefetch" href="/note/assets/js/7.3716808f.js"><link rel="prefetch" href="/note/assets/js/70.23b831ac.js"><link rel="prefetch" href="/note/assets/js/71.909ac76e.js"><link rel="prefetch" href="/note/assets/js/72.23351caf.js"><link rel="prefetch" href="/note/assets/js/73.cbc6b153.js"><link rel="prefetch" href="/note/assets/js/74.f429fecb.js"><link rel="prefetch" href="/note/assets/js/75.acdd5245.js"><link rel="prefetch" href="/note/assets/js/76.811d505c.js"><link rel="prefetch" href="/note/assets/js/77.c84d8881.js"><link rel="prefetch" href="/note/assets/js/78.cb06eda0.js"><link rel="prefetch" href="/note/assets/js/79.9d4b3a7a.js"><link rel="prefetch" href="/note/assets/js/8.7620b659.js"><link rel="prefetch" href="/note/assets/js/80.0e3ec1b9.js"><link rel="prefetch" href="/note/assets/js/81.febf1ef3.js"><link rel="prefetch" href="/note/assets/js/82.6ce2360e.js"><link rel="prefetch" href="/note/assets/js/83.359bd1bb.js"><link rel="prefetch" href="/note/assets/js/84.072c4726.js"><link rel="prefetch" href="/note/assets/js/85.7c969d8e.js"><link rel="prefetch" href="/note/assets/js/86.06c69440.js"><link rel="prefetch" href="/note/assets/js/87.9a696b54.js"><link rel="prefetch" href="/note/assets/js/88.e3c56aa1.js"><link rel="prefetch" href="/note/assets/js/89.ac1d22c1.js"><link rel="prefetch" href="/note/assets/js/9.71c0de2c.js"><link rel="prefetch" href="/note/assets/js/90.e5d4717b.js"><link rel="prefetch" href="/note/assets/js/91.160903e7.js"><link rel="prefetch" href="/note/assets/js/92.05ba7e8d.js"><link rel="prefetch" href="/note/assets/js/93.05384d4e.js"><link rel="prefetch" href="/note/assets/js/94.ae69e9a4.js"><link rel="prefetch" href="/note/assets/js/95.b059f23a.js"><link rel="prefetch" href="/note/assets/js/96.7de185cb.js"><link rel="prefetch" href="/note/assets/js/97.4a675554.js"><link rel="prefetch" href="/note/assets/js/98.2e3cb3ee.js"><link rel="prefetch" href="/note/assets/js/99.c692bd18.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.c9d983ba.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/note/css/css基础.html" class="nav-link">
  css 相关
</a></div><div class="nav-item"><a href="/note/react/react基础.html" class="nav-link">
  react 相关
</a></div><div class="nav-item"><a href="/note/js-patterns/代理模式.html" class="nav-link">
  js 设计模式
</a></div><div class="nav-item"><a href="/note/typescript/typescript基础语法.html" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/note/node/基础知识.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/note/javascript/知识体系.html" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/note/vue/相关笔记.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/note/webpack/基础知识.html" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/note/webgis/坐标系相关.html" class="nav-link">
  webgis
</a></div><div class="nav-item"><a href="/note/http/HTTP协议基础.html" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="nav-link">
  Interview
</a></div><div class="nav-item"><a href="/note/gisAlgorithm/数据结构-矢量.html" class="nav-link">
  gis 算法
</a></div><div class="nav-item"><a href="/note/graphics/图形学基础.html" class="nav-link">
  图形学相关
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/note/css/css基础.html" class="nav-link">
  css 相关
</a></div><div class="nav-item"><a href="/note/react/react基础.html" class="nav-link">
  react 相关
</a></div><div class="nav-item"><a href="/note/js-patterns/代理模式.html" class="nav-link">
  js 设计模式
</a></div><div class="nav-item"><a href="/note/typescript/typescript基础语法.html" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/note/node/基础知识.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/note/javascript/知识体系.html" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/note/vue/相关笔记.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/note/webpack/基础知识.html" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/note/webgis/坐标系相关.html" class="nav-link">
  webgis
</a></div><div class="nav-item"><a href="/note/http/HTTP协议基础.html" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="nav-link">
  Interview
</a></div><div class="nav-item"><a href="/note/gisAlgorithm/数据结构-矢量.html" class="nav-link">
  gis 算法
</a></div><div class="nav-item"><a href="/note/graphics/图形学基础.html" class="nav-link">
  图形学相关
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html" class="sidebar-link">forEach、for in、for of、map之间的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#foreach" class="sidebar-link">1️⃣ forEach</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#语法" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#参数" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#使用" class="sidebar-link">使用</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#不同点" class="sidebar-link">不同点</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#for-in" class="sidebar-link">2️⃣ for...in</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#语法-2" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#示例" class="sidebar-link">示例</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#遍历数组的缺点" class="sidebar-link">遍历数组的缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#for-of" class="sidebar-link">3️⃣ for...of</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#语法-3" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#示例-2" class="sidebar-link">示例</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#跳出循环" class="sidebar-link">跳出循环</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#与-for-in-的区别" class="sidebar-link">与 for...in 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#map" class="sidebar-link">4️⃣ map</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#语法-4" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#参数-2" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#返回值" class="sidebar-link">返回值</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/forEach-forIn-forOf-map之间的区别.html#补充说明" class="sidebar-link">✏️ 补充说明</a></li></ul></li><li><a href="/note/Interview/数据类型.html" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/数据类型.html#数据类型" class="sidebar-link">💫 数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/数据类型.html#number" class="sidebar-link">👉 Number</a></li><li class="sidebar-sub-header"><a href="/note/Interview/数据类型.html#string" class="sidebar-link">👉 String</a></li><li class="sidebar-sub-header"><a href="/note/Interview/数据类型.html#object" class="sidebar-link">👉 Object</a></li></ul></li></ul></li><li><a href="/note/Interview/操作符.html" class="sidebar-link">操作符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#操作符" class="sidebar-link">操作符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#一元操作符" class="sidebar-link">一元操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#布尔操作符" class="sidebar-link">布尔操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#逻辑或" class="sidebar-link">逻辑或</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#乘法操作符" class="sidebar-link">乘法操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#除法操作符" class="sidebar-link">除法操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#求模" class="sidebar-link">求模</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#加性操作符" class="sidebar-link">加性操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#关系操作符" class="sidebar-link">关系操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#相等操作符" class="sidebar-link">相等操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#逗号操作符" class="sidebar-link">逗号操作符</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#breack-和-continue-语句" class="sidebar-link">breack 和 continue 语句</a></li><li class="sidebar-sub-header"><a href="/note/Interview/操作符.html#switch-语句" class="sidebar-link">switch 语句</a></li></ul></li></ul></li><li><a href="/note/Interview/变量、作用域和内存.html" class="sidebar-link">变量、作用域和内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#变量、作用域和内存问题" class="sidebar-link">变量、作用域和内存问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#检测类型" class="sidebar-link">检测类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#执行环境以及作用域" class="sidebar-link">执行环境以及作用域</a></li><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#垃圾收集" class="sidebar-link">垃圾收集</a></li><li class="sidebar-sub-header"><a href="/note/Interview/变量、作用域和内存.html#javascript-v8-引擎的垃圾回收机制" class="sidebar-link">JavaScript V8 引擎的垃圾回收机制</a></li></ul></li></ul></li><li><a href="/note/Interview/引用类型.html" class="sidebar-link">引用类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#object-类型" class="sidebar-link">Object 类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#array-类型" class="sidebar-link">Array 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#date-类型" class="sidebar-link">Date 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#regexp-类型" class="sidebar-link">RegExp 类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#函数声明与函数表达式" class="sidebar-link">函数声明与函数表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#函数的内部属性" class="sidebar-link">函数的内部属性</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#函数属性和方法" class="sidebar-link">函数属性和方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#基本包装类型" class="sidebar-link">基本包装类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#boolean-对象" class="sidebar-link">Boolean 对象</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#number-类型" class="sidebar-link">Number 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#string-类型" class="sidebar-link">String 类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#单体内置对象" class="sidebar-link">单体内置对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#global-对象" class="sidebar-link">Global 对象</a></li><li class="sidebar-sub-header"><a href="/note/Interview/引用类型.html#math-对象" class="sidebar-link">Math 对象</a></li></ul></li></ul></li><li><a href="/note/Interview/对象的创建模式.html" class="sidebar-link">对象的创建模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#理解对象" class="sidebar-link">理解对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#属性类型" class="sidebar-link">属性类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#创建对象" class="sidebar-link">创建对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#工厂模式" class="sidebar-link">工厂模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#构造函数模式" class="sidebar-link">构造函数模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#原型模式" class="sidebar-link">原型模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#组合使用构造函数模式和原型模式（最常用的模式）" class="sidebar-link">组合使用构造函数模式和原型模式（最常用的模式）</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#动态原型模式" class="sidebar-link">动态原型模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#寄生构造函数模式" class="sidebar-link">寄生构造函数模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/对象的创建模式.html#稳妥构造函数模式" class="sidebar-link">稳妥构造函数模式</a></li></ul></li></ul></li><li><a href="/note/Interview/继承.html" class="sidebar-link">继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#原型链" class="sidebar-link">原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#默认的原型" class="sidebar-link">默认的原型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#确定原型和实例之间的关系" class="sidebar-link">确定原型和实例之间的关系</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#谨慎地定义方法" class="sidebar-link">谨慎地定义方法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#原型链的问题" class="sidebar-link">原型链的问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#借用构造函数" class="sidebar-link">借用构造函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#传递参数" class="sidebar-link">传递参数</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#借用构造函数存在的问题" class="sidebar-link">借用构造函数存在的问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#组合继承（最常用）" class="sidebar-link">组合继承（最常用）</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#原型式继承" class="sidebar-link">原型式继承</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#寄生式继承" class="sidebar-link">寄生式继承</a></li><li class="sidebar-sub-header"><a href="/note/Interview/继承.html#寄生组合式继承" class="sidebar-link">寄生组合式继承</a></li></ul></li><li><a href="/note/Interview/函数表达式.html" class="sidebar-link">函数表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#函数定义" class="sidebar-link">函数定义</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#函数声明" class="sidebar-link">函数声明</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#函数表达式" class="sidebar-link">函数表达式</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#创建闭包" class="sidebar-link">创建闭包</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#闭包与变量" class="sidebar-link">闭包与变量</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#关于-this-对象" class="sidebar-link">关于 this 对象</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#内存泄漏" class="sidebar-link">内存泄漏</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#模仿块级作用域" class="sidebar-link">模仿块级作用域</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#私有变量" class="sidebar-link">私有变量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#静态私有变量" class="sidebar-link">静态私有变量</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#模块模式" class="sidebar-link">模块模式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/函数表达式.html#增强的模块模式" class="sidebar-link">增强的模块模式</a></li></ul></li></ul></li><li><a href="/note/Interview/BOM.html" class="sidebar-link">BOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#window-对象" class="sidebar-link">window 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#全局作用域" class="sidebar-link">全局作用域</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#窗口关系及框架" class="sidebar-link">窗口关系及框架</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#窗口位置" class="sidebar-link">窗口位置</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#窗口大小" class="sidebar-link">窗口大小</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#导航和打开窗口" class="sidebar-link">导航和打开窗口</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#settimeout-setinterval" class="sidebar-link">setTimeout/setInterval</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#系统对话框" class="sidebar-link">系统对话框</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#location-对象" class="sidebar-link">location 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#查询字符串参数" class="sidebar-link">查询字符串参数</a></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#位置操作" class="sidebar-link">位置操作</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#nagigator-对象" class="sidebar-link">nagigator 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#检查插件" class="sidebar-link">检查插件</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/BOM.html#history-对象" class="sidebar-link">history 对象</a></li></ul></li><li><a href="/note/Interview/DOM.html" class="sidebar-link">DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#节点层次" class="sidebar-link">节点层次</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#node-类型" class="sidebar-link">Node 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#document-类型" class="sidebar-link">Document 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#element-类型" class="sidebar-link">Element 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#text-类型" class="sidebar-link">Text 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#comment-类型" class="sidebar-link">Comment 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#documenttype-类型" class="sidebar-link">DocumentType 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#documentfragment-类型" class="sidebar-link">DocumentFragment 类型</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#attr-属性" class="sidebar-link">Attr 属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#dom-操作技术" class="sidebar-link">DOM 操作技术</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#动态脚本" class="sidebar-link">动态脚本</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#动态样式" class="sidebar-link">动态样式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM.html#操作表格" class="sidebar-link">操作表格</a></li></ul></li></ul></li><li><a href="/note/Interview/DOM扩展.html" class="active sidebar-link">DOM扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#选择符-api" class="sidebar-link">选择符 API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#queryselector-方法" class="sidebar-link">querySelector() 方法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#querysekectorall-方法" class="sidebar-link">querySekectorAll() 方法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#matches-方法" class="sidebar-link">matches() 方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#元素遍历" class="sidebar-link">元素遍历</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#html-5" class="sidebar-link">HTML 5</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#css-类扩展" class="sidebar-link">CSS 类扩展</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#焦点管理" class="sidebar-link">焦点管理</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#htmldocument-扩展" class="sidebar-link">HTMLDocument 扩展</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#字符集属性" class="sidebar-link">字符集属性</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#自定义属性" class="sidebar-link">自定义属性</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#插入标记" class="sidebar-link">插入标记</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#专有扩展" class="sidebar-link">专有扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#children-属性" class="sidebar-link">children 属性</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM扩展.html#contains-方法" class="sidebar-link">contains() 方法</a></li></ul></li></ul></li><li><a href="/note/Interview/DOM2和DOM3.html" class="sidebar-link">DOM2和DOM3</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#dom2、dom3" class="sidebar-link">DOM2、DOM3</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#dom-变化" class="sidebar-link">DOM 变化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#documenttype-类型的变化" class="sidebar-link">DocumentType 类型的变化</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#document-的变化" class="sidebar-link">Document 的变化</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#node-的变化" class="sidebar-link">Node 的变化</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#框架的变化" class="sidebar-link">框架的变化</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#样式" class="sidebar-link">样式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#dom-样式属性和方法" class="sidebar-link">DOM 样式属性和方法</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#计算的样式" class="sidebar-link">计算的样式</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#操作样式表" class="sidebar-link">操作样式表</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#元素大小" class="sidebar-link">元素大小</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#遍历" class="sidebar-link">遍历</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#nodeiterator" class="sidebar-link">NodeIterator</a></li><li class="sidebar-sub-header"><a href="/note/Interview/DOM2和DOM3.html#treewalker" class="sidebar-link">TreeWalker</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="选择符-api"><a href="#选择符-api" class="header-anchor">#</a> 选择符 API</h2> <p>Selectors API Level 1 的核心是两个方法：querySelector() 和 querySelectorAll() 。在兼容浏览器中， Document 类型和 Element 类型的实例上都会暴露这两个方法。Selectors API Level 2 规范在 Element 类型上新增了更多方法，比如 matches() 、 find() 和 findAll() 。不过，目前还没有浏览器实现或宣称实现 find() 和 findAll()。</p> <h3 id="queryselector-方法"><a href="#queryselector-方法" class="header-anchor">#</a> querySelector() 方法</h3> <p>querySelector() 方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回 null 。如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 取得 body 元素</span>
<span class="token keyword">let</span> body <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span>

<span class="token comment">// 获取 id 为 mydiv 的元素</span>
<span class="token keyword">let</span> myDiv <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#mydiv'</span><span class="token punctuation">)</span>

<span class="token comment">// 获取类名为 selected 的第一个元素</span>
<span class="token keyword">let</span> selected <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.selected'</span><span class="token punctuation">)</span>

<span class="token comment">// 获取类名为 button 的第一个 img 元素</span>
<span class="token keyword">let</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'img.button'</span><span class="token punctuation">)</span>
</code></pre></div><p>在 Document 上使用 querySelector() 方法时，会从文档元素开始搜索；在 Element 上使用 querySelector() 方法时，则只会从当前元素的后代中查询。</p> <h3 id="querysekectorall-方法"><a href="#querysekectorall-方法" class="header-anchor">#</a> querySekectorAll() 方法</h3> <p>querySelectorAll() 方法跟 querySelector() 一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个 NodeList 的静态实例。需要注意的是：querySelectorAll() 返回的 NodeList 实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用 NodeList 对象可能造成的性能问题。如果没有匹配项，则返回空的 NodeList 实例。</p> <p>与 querySelector() 一样， querySelectorAll() 也可以在 Document 、 DocumentFragment 和 Element 类型上使用。下面是几个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 获取 id 为 mydiv 的 div 元素中的所有 em 元素</span>
<span class="token keyword">let</span> ems <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'mydiv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'em'</span><span class="token punctuation">)</span>

<span class="token comment">// 获取所有类名中包含 selected 的元素</span>
<span class="token keyword">let</span> selecteds <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.selected'</span><span class="token punctuation">)</span>

<span class="token comment">// 获取所有是 p 元素子元素的 strong 元素</span>
<span class="token keyword">let</span> strongs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'p strong'</span><span class="token punctuation">)</span>

</code></pre></div><p>返回的 NodeList 对象可以通过 for-of 循环、 item() 方法或中括号语法取得个别元素。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> strongElements <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">&quot;p strong&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 以下 3 个循环的效果一样</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> strong <span class="token keyword">of</span> strongElements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strong<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">&quot;important&quot;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strongElements<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strongElements<span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">&quot;important&quot;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strongElements<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strongElements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">&quot;important&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="matches-方法"><a href="#matches-方法" class="header-anchor">#</a> matches() 方法</h3> <p>matches() 方法（在规范草案中称为 matchesSelector()）接收一个 CSS 选择符参数，如果元素匹配则该选择符返回 true ，否则返回 false 。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>dcoument<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">'body.page1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用这个方法可以方便地检测某个元素会不会被 querySelector() 或 querySelectorAll() 方法返回。</p> <h2 id="元素遍历"><a href="#元素遍历" class="header-anchor">#</a> 元素遍历</h2> <p>IE9 之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了 childNodes 和 firstChild 等属性上的差异。为了弥补这个差异，同时不影响 DOM规范，W3C 通过新的 Element Traversal 规范定义了一组新属性。Element Traversal API 为 DOM 元素添加了 5 个属性：</p> <ul><li>childElementCount ，返回子元素数量（不包含文本节点和注释）；</li> <li>firstElementChild ，指向第一个 Element 类型的子元素（ Element 版 firstChild ）；</li> <li>lastElementChild ，指向最后一个 Element 类型的子元素（ Element 版 lastChild ）；</li> <li>previousElementSibling ， 指 向 前 一 个 Element 类 型 的 同 胞 元 素 （ Element 版 previousSibling ）；</li> <li>nextElementSibling ，指向后一个 Element 类型的同胞元素（ Element 版 nextSibling ）。</li></ul> <p>举个例子，过去要以跨浏览器方式遍历特定元素的所有子元素，代码大致是这样写的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> parentElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'parent'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> currentChildNode <span class="token operator">=</span> parentElement<span class="token punctuation">.</span>firstChild<span class="token punctuation">;</span>
<span class="token comment">// 没有子元素，firstChild 返回 null，跳过循环</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>currentChildNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentChildNode<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果有元素节点，则做相应处理</span>
    <span class="token function">processChild</span><span class="token punctuation">(</span>currentChildNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentChildNode <span class="token operator">===</span> parentElement<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  currentChildNode <span class="token operator">=</span> currentChildNode<span class="token punctuation">.</span>nextSibling<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用 Element Traversal 属性之后，以上代码可以简化如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> parentElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'parent'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> currentChildElement <span class="token operator">=</span> parentElement<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">;</span>
<span class="token comment">// 没有子元素，firstElementChild 返回 null，跳过循环</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>currentChildElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这就是元素节点，做相应处理</span>
  <span class="token function">processChild</span><span class="token punctuation">(</span>currentChildElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentChildElement <span class="token operator">===</span> parentElement<span class="token punctuation">.</span>lastElementChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  currentChildElement <span class="token operator">=</span> currentChildElement<span class="token punctuation">.</span>nextElementSibling<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="html-5"><a href="#html-5" class="header-anchor">#</a> HTML 5</h2> <p>HTML5 代表着与以前的 HTML 截然不同的方向。在所有以前的 HTML 规范中，从未出现过描述 JavaScript 接口的情形，HTML 就是一个纯标记语言。JavaScript 绑定的事，一概交给 DOM 规范去定义。然而，HTML5 规范却包含了与标记相关的大量 JavaScript API 定义。其中有的 API 与 DOM 重合，定义了浏览器应该提供的 DOM扩展。</p> <h3 id="css-类扩展"><a href="#css-类扩展" class="header-anchor">#</a> CSS 类扩展</h3> <ul><li>getElementsByClassName() 方法</li></ul> <p>可以通过 document 对象及所有 HTML 元素调用该方法。该方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的 NodeList。传入多个类名时，类名的先后顺序不重要。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 取得所有类名中包含 username 和 current 的元素</span>
<span class="token keyword">let</span> allCurrentUserNames <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'username current'</span><span class="token punctuation">)</span>

<span class="token comment">// 取得 id 为 mydiv 的元素子树中所有包含 selected 类的元素</span>
<span class="token keyword">let</span> selected <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'mydiv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'selected'</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>classList 属性</li></ul> <p>在操作类名时，需要通过 className 属性添加、删除和替换类名。因为 className 中是一个字符串，所以即使值修改字符串一部分，也必须每次都设置整个字符串的值。
如下代码：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>bd user disabled<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>如果想要删除其中一个：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 要删除 user 类</span>
<span class="token keyword">let</span> tatgetClass <span class="token operator">=</span> <span class="token string">'user'</span>

<span class="token comment">// 把类名拆成数组</span>
<span class="token keyword">let</span> classNames <span class="token operator">=</span> div<span class="token punctuation">.</span>className<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token regex">/\S+/</span><span class="token punctuation">)</span>

<span class="token comment">// 找到要删除类名的索引</span>
<span class="token keyword">let</span> idx <span class="token operator">=</span> classNames<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>tatgetClass<span class="token punctuation">)</span>

<span class="token comment">// 如果有则删除</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>idx <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  classNames<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 重新设置类名</span>
div<span class="token punctuation">.</span>className <span class="token operator">=</span> classNames<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>
</code></pre></div><p>HTML5 新增了一种操作类名的方式，为所有元素添加了 classList 属性，classList 是一个新的集合类型 DOMTokenList 的实例，与其他 DOM 集合类型一样， DOMTokenList
也有 length 属性表示自己包含多少项，也可以通过 item() 或中括号取得个别的元素。此外，DOMTokenList 还增加了以下方法。</p> <ul><li>add(value) ，向类名列表中添加指定的字符串值 value 。如果这个值已经存在，则什么也不做。</li> <li>contains(value) ，返回布尔值，表示给定的 value 是否存在。</li> <li>remove(value) ，从类名列表中删除指定的字符串值 value 。</li> <li>toggle(value) ，如果类名列表中已经存在指定的 value ，则删除；如果不存在，则添加。</li></ul> <p>上面的例子就可以使用一句代码替换：</p> <div class="language-js extra-class"><pre class="language-js"><code>div<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="焦点管理"><a href="#焦点管理" class="header-anchor">#</a> 焦点管理</h3> <p>HTML5 增加了辅助 DOM 焦点管理的功能。首先是 document.activeElement ，始终包含当前拥有焦点的 DOM元素。
默认情况下， document.activeElement 在页面刚加载完之后会设置为 document.body 。而在页面完全加载之前， document.activeElement 的值为 null 。</p> <p>其次是 document.hasFocus() 方法，该方法返回布尔值，表示文档是否拥有焦点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myButton'</span><span class="token punctuation">)</span>
button<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">hasFocus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="htmldocument-扩展"><a href="#htmldocument-扩展" class="header-anchor">#</a> HTMLDocument 扩展</h3> <ol><li>readyState 属性
document.readyState 属性有两个可能的值：</li></ol> <ul><li>loading: 正在加载文档</li> <li>complete: 已经加载完文档</li></ul> <p>实际开发中，最好是把 document.readState 当成一个指示器，以判断文档是否加载完毕。这个属性的基本用法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token string">'complete'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行操作</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>兼容模式</li></ol> <p>自从 IE6 提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。IE 为 document 添加了 compatMode 属性，这个属性唯一的任务是指示浏览器当前处于什么渲染模式。如下面的例子所示，标准模式下 document.compatMode 的值是 &quot;CSS1Compat&quot; ，而在混杂模式下，document.compatMode 的值是 &quot;BackCompat&quot; ：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>compatMode <span class="token operator">===</span> <span class="token string">'CSS1Compat'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Standards mode'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Quirks mode'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>head 属性</li></ol> <p>作为对 document.body （指向文档的 body 元素）的补充，HTML5 增加了 document.head 属性，指向文档的 head 元素。可以像下面这样直接取得 head 元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> head <span class="token operator">=</span> document<span class="token punctuation">.</span>head <span class="token operator">||</span> document<span class="token punctuation">.</span><span class="token function">getElementByTagName</span><span class="token punctuation">(</span><span class="token string">'head'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre></div><h3 id="字符集属性"><a href="#字符集属性" class="header-anchor">#</a> 字符集属性</h3> <p>HTML5 增加了几个与文档字符集有关的新属性。其中， characterSet 属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是 &quot;UTF-16&quot; ，但可以通过 meta 元素或响应头，以及新增的 characterSet 属性来修改。下面是一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>characterSet<span class="token punctuation">)</span> <span class="token comment">// &quot;UTF-16&quot;</span>
document<span class="token punctuation">.</span>characterSet <span class="token operator">=</span> <span class="token string">'UTF-8'</span>
</code></pre></div><h3 id="自定义属性"><a href="#自定义属性" class="header-anchor">#</a> 自定义属性</h3> <p>HTML5 允许给元素指定非标准的属性，但要使用前缀 data- 以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>myDiv<span class="token punctuation">&quot;</span></span> <span class="token attr-name">data-appId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>12345<span class="token punctuation">&quot;</span></span> <span class="token attr-name">data-myname</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>Nicholas<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>定义了自定义数据属性后，可以通过元素的 dataset 属性来访问。 dataset 属性是一个 DOMStringMap 的实例，包含一组键/值对映射。元素的每个 data-name 属性在 dataset 中都可以通过 data- 后面的字符串作为键来访问。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'mydiv'</span><span class="token punctuation">)</span>
<span class="token comment">// 取得自定义属性的值</span>
<span class="token keyword">let</span> appid <span class="token operator">=</span> div<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>appid
<span class="token keyword">let</span> myName <span class="token operator">=</span> div<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>myname

<span class="token comment">// 设置值</span>
div<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>appid <span class="token operator">=</span> <span class="token number">23456</span>
div<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>myname <span class="token operator">=</span> <span class="token string">'Michael'</span>

<span class="token comment">// 有没有 myname</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>div<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>myname<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>div<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>myname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="插入标记"><a href="#插入标记" class="header-anchor">#</a> 插入标记</h3> <ul><li>innerHTML 属性</li></ul> <p>该属性会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点，如果设置该属性，则会根据提供的字符串值以新的 DOM 子树替代元素中原来包含的所有节点。对于读取 innerHTML 属性，不同的浏览器返回的结果是不同的。如果赋值中不包含任何 HTML 标签，则直接生成一个文本节点。</p> <p>使用 innerHTNL 插入的 script 标签是不会执行的。多数浏览器支持使用 innerHTML 插入 style 元素。</p> <ul><li>outerHTML 属性</li></ul> <p>读取 outerHTML 属性时，会返回调用它的元素（及所有后代元素）的 HTML 字符串。在写入 outerHTML 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。比如下面的 HTML 代码：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>content<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>This is a <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">&gt;</span></span>paragraph<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">&gt;</span></span> with a list following it.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Item 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Item 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Item 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在这个 div 元素上调用 outerHTML 会返回相同的字符串，包括 div 本身。
如果使用 outerHTML 设置 HTML，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>div<span class="token punctuation">.</span>outerHTML <span class="token operator">=</span> <span class="token string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>
</code></pre></div><p>则会得到与执行以下脚本相同的结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">&quot;This is a paragraph.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> div<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>新的 p 元素会取代 DOM 树中原来的 div 元素。</p> <ul><li>insertAdjacentHTML() 与 insertAdjacentText()</li></ul> <p>这两个方法时插入标签的方法；它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本。第一个参数必须是下列值中的一个：</p> <ul><li>&quot;beforebegin&quot; ，插入当前元素前面，作为前一个同胞节点；</li> <li>&quot;afterbegin&quot; ，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；</li> <li>&quot;beforeend&quot; ，在当前元素之下插入一个新的子元素或在最后一个个子元素之前再插入新的子元素；</li> <li>&quot;afterend&quot; ，插入当前元素后面，作为下一个同胞节点</li></ul> <p>假设当前元素是</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Hello world!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span> 
</code></pre></div><p>则 &quot;beforebegin&quot; 和 &quot;afterbegin&quot; 中的 &quot;begin&quot; 指开始标签 p ；而&quot;afterend&quot; 和 &quot;beforeend&quot; 中的 &quot;end&quot; 指结束标签 p 。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 作为前一个同胞节点插入</span>
element<span class="token punctuation">.</span><span class="token function">insertAdjacentHTML</span><span class="token punctuation">(</span><span class="token string">&quot;beforebegin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span><span class="token function">insertAdjacentText</span><span class="token punctuation">(</span><span class="token string">&quot;beforebegin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 作为第一个子节点插入</span>
element<span class="token punctuation">.</span><span class="token function">insertAdjacentHTML</span><span class="token punctuation">(</span><span class="token string">&quot;afterbegin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span><span class="token function">insertAdjacentText</span><span class="token punctuation">(</span><span class="token string">&quot;afterbegin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 作为最后一个子节点插入</span>
element<span class="token punctuation">.</span><span class="token function">insertAdjacentHTML</span><span class="token punctuation">(</span><span class="token string">&quot;beforeend&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span><span class="token function">insertAdjacentText</span><span class="token punctuation">(</span><span class="token string">&quot;beforeend&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 作为下一个同胞节点插入</span>
element<span class="token punctuation">.</span><span class="token function">insertAdjacentHTML</span><span class="token punctuation">(</span><span class="token string">&quot;afterend&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> element<span class="token punctuation">.</span>
<span class="token function">insertAdjacentText</span><span class="token punctuation">(</span><span class="token string">&quot;afterend&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>scrollIntoView() 方法</li></ul> <p>scrollIntoView() 方法可以在所有 HTML 元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。
有两个参数；</p> <p>alignToTop 是一个布尔值：</p> <ul><li>true ：窗口滚动后元素的顶部与视口顶部对齐。</li> <li>false ：窗口滚动后元素的底部与视口底部对齐。</li></ul> <p>scrollIntoViewOptions 是一个选项对象：</p> <ul><li>behavior ：定义过渡动画，可取的值为 &quot;smooth&quot; 和 &quot;auto&quot; ，默认为 &quot;auto&quot; 。</li> <li>block ：定义垂直方向的对齐，可取的值为 &quot;start&quot; 、 &quot;center&quot; 、 &quot;end&quot; 和 &quot;nearest&quot; ，默
认为 &quot;start&quot; 。</li> <li>inline ：定义水平方向的对齐，可取的值为 &quot;start&quot; 、 &quot;center&quot; 、 &quot;end&quot; 和 &quot;nearest&quot; ，默
认为 &quot;nearest&quot; 。</li></ul> <p>不传参数等同于 alignToTop 为 true 。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 确保元素可见</span>
document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 同上</span>
document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  block<span class="token operator">:</span> <span class="token string">'start'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 尝试将元素平滑地滚入视口</span>
document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  behavior<span class="token operator">:</span> <span class="token string">'smooth'</span><span class="token punctuation">,</span>
  block<span class="token operator">:</span> <span class="token string">'start'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="专有扩展"><a href="#专有扩展" class="header-anchor">#</a> 专有扩展</h2> <h3 id="children-属性"><a href="#children-属性" class="header-anchor">#</a> children 属性</h3> <p>元素的 childNodes 包含所有子节点，这些子节点可能是其他元素、文本节点、注释或处理指令；children 属性是一个 HTMLCollection ，只包含元素的 Element 类型的子节点；</p> <h3 id="contains-方法"><a href="#contains-方法" class="header-anchor">#</a> contains() 方法</h3> <p>DOM 编程中经常需要确定一个元素是不是另一个元素的后代。IE 首先引入了 contains() 方法，让开发者可以在不遍历 DOM 的情况下获取这个信息。 contains() 方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点。</p> <p>如果目标节点是被搜索节点的后代，contains() 返回 true ，否则返回 false 。下面看一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>这个例子测试 html 元素中是否包含 body 元素，在格式正确的 HTML 中会返回 true 。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新:</span> <span class="time">10/14/2020, 8:52:02 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/Interview/DOM.html" class="prev">
        DOM
      </a></span> <span class="next"><a href="/note/Interview/DOM2和DOM3.html">
        DOM2和DOM3
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/note/assets/js/app.7916f9d6.js" defer></script><script src="/note/assets/js/2.4766c975.js" defer></script><script src="/note/assets/js/47.f18b0fed.js" defer></script>
  </body>
</html>
